[
  {
    "objectID": "clones/DynamicsSimulations/problem09/README.html",
    "href": "clones/DynamicsSimulations/problem09/README.html",
    "title": "problem09",
    "section": "",
    "text": "9. Canon ball. A cannon ball m is launched at angle θ and speed v0. It is acted on by gravity g and a viscous drag with magnitude \\(\\|c\n\\vec{v}\\|\\).\n(a) Find position vs time analytically.  \n(b) Find a numerical solution using θ = π/4, v0 = 1 m/s, g = 1 m/s 2 , m = 1 kg, c = 1 kg/ s.  \n(c) Compare the numeric and analytic solutions. At t = 2 how big is the error? How does the error depend on specified tolerances or step sizes?  \n(d) Use larger and larger values of v0 and for each trajectory choose a time interval so the canon at least gets back to the ground. Plot the trajectories (using equal scale for the x and y axis. Plot all curves on one plot. As v → ∞ what is the eventual shape? [Hint: the answer is simple and interesting.]  \n(e) For any given v0 there is a best launch angle θ ∗ for maximizing the range. As v0 → ∞ to what angle does θ ∗ tend? Justify your answer as best you can with careful numerics, analytical work, or both.  \n\n\nFind position vs time analytically.\nThe corresponding code for this in file ./Ballistics/src/Ballistics.jl:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    u = zeros((4,))\n    u[1] = vx0 * (-c/m) * (exp((-c/m)*(t-t0)) - 1)\n    u[2] = ((vy0+(m*g/c))*(-c/m)*(exp((-c/m)*(t-t0)) - 1)) + ((-m*g/c)*(t-t0))\n    u[3] = (vx0) * (exp((-c/m)*(t-t0)))\n    u[4] = ((vy0) + (m*g/c)) * exp((-c/m)*(t-t0)) - (m*g/c)\n\n    return u\nend\nThis turned out to be wrong, it was an integral mistake (integration mistake). The corrected version in the same file:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    x = x0 + vx0 * ((-m / c) * exp((c / m) * (t0))) * (exp((-c / m) * t) - exp((-c / m) * t0))\n    y = y0 + ((vy0 + (m * g / c)) * (-m / c) * (exp((c / m) * t0)) * (exp((-c / m) * t) - exp((-c / m) * t0))) + ((-m * g / c) * (t - t0))\n    vx = (vx0) * (exp((-c / m) * (t - t0)))\n    vy = ((vy0) + (m * g / c)) * exp((-c / m) * (t - t0)) - (m * g / c)\n\n    u = zeros((4,))\n    u[1] = x\n    u[2] = y\n    u[3] = vx\n    u[4] = vy\n\n    return u\nend\n\n\nTODO: Could I have created this analytical solution symbolically?\n\n\nFind a numerical solution using given parameters\nThe corresponding code for this in file ./Ballistics/src/Ballistics.jl:\nusing DifferentialEquations\n#...\n# problem setup\nx0, y0 = 0.0, 0.0\nr0 = [x0; y0]\nspeed0 = 1\nlaunchangle = pi / 4\nvx0, vy0 = speed0 * [cos(launchangle); sin(launchangle)]\nv0 = [vx0; vy0]\nu0 = [r0; v0]\n\nt0 = 0.0\ntend = 1.0\ntspan = (t0, tend)\np = Parameters.Param(m=1, g=1, c=1)\nprob = ODEProblem(Physics.ballistic!, u0, tspan, p)\n#...\nsol_numeric = solve(prob)\n#...\nVisualization.plot_trajectory(sol_numeric.u)\nThis numerical solution gives the following trajectory:\n\n\n\n../media/problem09/numerical_trajectory.png\n\n\n\n\nCompare the numeric and analytics solutions? Plot time vs error. Plot step size and tolerances vs error.\nFor various initial conditions, the numeric and analytical solutions on the same graph, I was shifting the analytic in x direction by 0.1 unit to be able view both, otherwise they were overlapping with the default tolerances, but then I ended up using a non-dynamic step size explicit solver:\nIn file ./Ballistics/src/Benchmarks.jl:\nmodule Benchmarks\n\nusing DifferentialEquations\nusing LinearAlgebra\n\n# Abs error for various step sizes\nfunction abs_error_vs_step_sizes(prob, analytical_solve)\n    # step_sizes = 10.0 .^ range(-1, -15, step=-1)\n    step_sizes = 10.0 .^ range(-1, -5, step=-1)\n    abs_errors_midpoint = Vector{Union{Missing, Float64}}(missing, length(step_sizes))\n    abs_errors_rk4 = Vector{Union{Missing, Float64}}(missing, length(step_sizes))\n\n    for (i,Δh) in enumerate(step_sizes)\n        sol_numeric_midpoint = solve(prob, Midpoint(), dt=Δh, adaptive=false, save_everystep=false)[end]\n        sol_numeric_rk4 = solve(prob, RK4(), dt=Δh, adaptive=false, save_everystep=false)[end]\n        tend = prob.tspan[2]\n        sol_analytic = analytical_solve(tend)\n\n        separation_midpoint = sol_numeric_midpoint - sol_analytic\n        separation_rk4 = sol_numeric_rk4 - sol_analytic\n        error_midpoint = norm(separation_midpoint)\n        error_rk4 = norm(separation_rk4)\n    \n        abs_errors_midpoint[i] = error_midpoint\n        abs_errors_rk4[i] = error_rk4\n    end\n\n    log_errors_midpoint = log10.(abs_errors_midpoint)\n    log_errors_rk4 = log10.(abs_errors_rk4)\n    log_errors_dict = Dict(\"midpoint\"=&gt;log_errors_midpoint, \"rk4\"=&gt; log_errors_rk4)\n    log_steps = log10.(step_sizes)\n\n    return log_steps, log_errors_dict\nend\n\n# Abs error for all times\nfunction error_vs_time(prob, analytical_solve)\n    N = 5\n    step_sizes = 10.0 .^ range(-1, -N, step=-1)\n    time_histories = Vector{Union{Missing, Vector{Float64}}}(missing, length(step_sizes))\n    error_histories = Vector{Union{Missing, Vector{Float64}}}(missing, length(step_sizes))\n    for (i,Δh) in enumerate(step_sizes)\n        sol = solve(prob, Midpoint(), dt=Δh, adaptive=false, save_everystep=true)\n\n        timestamps = sol.t\n        sol_numeric_midpoint = sol.u\n        sol_analytic = analytical_solve.(timestamps)\n\n        separations = sol_numeric_midpoint .- sol_analytic\n        manhatten_errors = norm.(separations, Ref(1))\n        error_histories[i] = log10.(manhatten_errors)\n        time_histories[i] = timestamps\n    end\n    return time_histories, error_histories\nend\n\n\nend # module Benchmarks\n\n\n\n../media/problem09/numeric_and_analytical_trajectories.png\n\n\nNow, I will plot the steps sizes vs error (euclidean norm of state vector at tend):\n\n\n\n../media/problem09/steps_vs_error.png\n\n\nFor a better method, like RK4, on the same graph:\n\n\n\n../media/problem09/steps_vs_error_two_methods_compare.png\n\n\nNow, for time vs error compilation:\n\n\n\n../media/problem09/time_vs_running_error.png\n\n\nNow, I will change the relative tolerance and absolute tolerance. In file ./Ballistics/src/Benchmarks.jl:\nfunction tolerances_vs_error(prob, analytical_solve)\n    N = 15\n    error_matrix = Matrix{Float64}(undef, N, N)\n    num_granularity = N+7\n    abstols = 10.0 .^ range(7, -N, length=num_granularity)\n    reltols = 10.0 .^ range(7, -N, length=num_granularity)\n\n    num_samples = length(abstols)*length(reltols)\n\n    xs = Vector{Float64}(undef, num_samples)\n    ys = Vector{Float64}(undef, num_samples)\n    zs = Vector{Float64}(undef, num_samples)\n\n    for (i, abstol) in enumerate(abstols)\n        for (j, reltol) in enumerate(reltols)\n            sol_numeric = solve(prob, Midpoint(), adaptive=true, save_everystep=false, abstol=abstol, reltol=reltol)[end]\n            sol_analytic = analytical_solve(prob.tspan[2])\n\n            separation = sol_numeric - sol_analytic\n            error = norm(separation)\n            xs[i+num_granularity*(j-1)] = abstol\n            ys[i+num_granularity*(j-1)] = reltol\n            zs[i+num_granularity*(j-1)] = error\n        end\n    end\n    xs,ys,zs\nend\nJust by mistake I ran this for large (&gt;1.0) tolerances. Below is the plot:\n\n\n\n../media/problem09/large_tolerances.png\n\n\nSimilarly for tiny (&lt;&lt;1.0) tolerances the plot:\n\n\n\n../media/problem09/small_tolerances.png\n\n\nBoth scales on the same graph:\n\n\n\n../media/problem09/tolerances_vs_error_combined.png\n\n\nSimply put, it seems reducing both abstol and reltol generally reduces error from the analytic solution very quickly. What is the meaning of both is not yet entirely clear.\n\n\nUse larger and larger values of v0, plot all of their trajectory till ball hits ground. What happens to the eventual shape as v -&gt; ∞ ?\nThe code for this in file ./Ballistics/src/Ballistics.jl:\n# ...\n\nfunction solve_till_empty(prob)\n    conditionatbeggining(u, t, integrator) = t &gt; 0\n    removetstop!(integrator) = add_tstop!(integrator, ∞)\n    removetstopwhenbeginning = DiscreteCallback(conditionatbeggining,removetstop!)\n\n    condition(u, t, integrator) = u[2] &lt; 0\n    affect!(integrator) = terminate!(integrator)\n    stopwhenonground = DiscreteCallback(condition, affect!)\n\n    cb = CallbackSet(removetstopwhenbeginning, stopwhenonground)\n    sol = solve(prob, RK4(), callback = cb, tstops = [0.1,])\n\n    sol\nend\n\nfunction problem_setup(launchangle, speed0, c)\n    x0, y0 = 0.0, 0.0\n    r0 = [x0; y0]\n    vx0, vy0 = speed0 * [cos(launchangle); sin(launchangle)]\n    v0 = [vx0; vy0]\n    u0 = [r0; v0]\n\n    t0 = 0.0\n    tend = 1.0\n    tspan = (t0, tend)\n    p = Parameters.Param(m = 1, g = 1, c = c)\n    prob = ODEProblem(Physics.ballistic!, u0, tspan, p)\n    return prob\nend\n\nspeeds = range(0, 100)\nproblems = problem_setup.(Ref(pi/4), speeds, Ref(1))\nsols = solve_till_empty.(problems)\nVisualization.plot_all_trajectories(sols)\n\n# ...\nThe plot corresponding to this:\n\n\n\nIncreasing intial velocities\n\n\n\n\nPlot speed verses best launch angle, numerically or analyticaly or both\nI expect 45 degrees to still be consistantly good for launch even with drag.\nDoing this numerically, in file ./Ballistics/src/Benchmarks.jl:\n# ...\n\nfunction best_angle_for_speed(speed0, c)\n    launchangles = pi/4 .* ((range(-1.0, 1.0, 300)) .^ 3.0 .+ 1.0)\n\n    max_range = 0\n    argmax_theta = 0\n    for launchangle in launchangles\n        # problem setup\n        prob = problem_setup(launchangle, speed0, c)\n\n        sol = solve_till_empty(prob)\n        cur_range = sol.u[end][1]\n        if cur_range &gt; max_range\n            max_range = cur_range\n            argmax_theta = launchangle\n        end\n    end\n    argmax_theta\nend\n\nspeeds = 10.0 .^ range(0.0, 3.1, 100)\nbestangles = []\nfor speed0 in speeds\n    bestangle = best_angle_for_speed(speed0, 1)\n    push!(bestangles, bestangle)\nend\nVisualization.plot_best_angle_for_speeds(speeds, bestangles)\n\n# ...\nThe weird choice for launchangles is for concentrating numeric choices for launchangles near \\(\\pi \\over 4\\). This produces:\n\n\n\n../media/problem09/speed_vs_bestangle_c_1.png\n\n\n\n\n\n../media/problem09/speed_vs_bestangle_c_10.png\n\n\nIt seems that my intuition was way off. It seems the best angle quickly becomes closer to zero as the initial velocity increases.\nLet us plot the relation of drag with the best angle for a high velocity (say v = 1200), in file ./Ballistics/src/Ballistics.jl:\nspeed0 = 1200.0\nbestangles = []\ndrags = 2.0 .^ range(1.0, 5.0)\nfor c in drags\n    bestangle = best_angle_for_speed(speed0, c)\n    push!(bestangles, bestangle)\nend\nVisualization.plot_best_angle_vs_drag(drags, bestangles)\n\n\nTODO: There isn’t much change in the eventual best angle for large velocities as drag changes. It does not seem right, but the best angle in such case seems to be some constant close to zero. I will explore this more later. The plot generated by above code is:\n\n\n\n../media/problem09/best_angle_vs_drag.png\n\n\nThis concludes my attempt of problem09."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem07/README.html",
    "href": "clones/DynamicsSimulations/problem07/README.html",
    "title": "problem07",
    "section": "",
    "text": "Simple animation of a shape. Draw a picture of some object (a face, a house, whatever), and make it move around on the screen in a smooth and interesting way. No distortions. Just motions and rotations\n\n\nIn file ./simple_animation.jl:\nusing GLMakie\n\n# Create a figure\nfig = Figure(resolution = (800, 600))\nax = GLMakie.Axis(fig[1, 1], aspect = DataAspect())\nlimits!(ax, -5, 5, -5, 5)\n\n# Define the house vertices (centered at origin)\nhouse_vertices = [\n    # Main square\n    Point2f(-1, -1), Point2f(1, -1), Point2f(1, 1), Point2f(-1, 1), Point2f(-1, -1),\n    # Roof\n    Point2f(-1, 1), Point2f(0, 2), Point2f(1, 1)\n]\n\n# Create initial lines object\nhouse_lines = lines!(ax, house_vertices, color = :blue, linewidth = 2)\n\n# Animation parameters\nframes = 300\nangular_speed = 2π/frames  # Complete one rotation\ndrift_speed = 4/frames    # Total drift distance\n\n# Create the animation\nrecord(fig, \"rotating_house.gif\", 1:frames; framerate = 30) do frame\n    # Calculate rotation and drift\n    angle = angular_speed * frame\n    drift_x = drift_speed * frame - 2  # Start from left side\n    drift_y = sin(2π * frame/frames)   # Add some vertical oscillation\n    \n    # Apply transformation to each point\n    transformed_points = [\n        Point2f(\n            x * cos(angle) - y * sin(angle) + drift_x,  # Rotation + horizontal drift\n            x * sin(angle) + y * cos(angle) + drift_y   # Rotation + vertical oscillation\n        )\n        for (x, y) in [(p[1], p[2]) for p in house_vertices]\n    ]\n    \n    # Update the lines object\n    house_lines[1] = transformed_points\nend\nProduces this animation:\n\n\n\nFloating house in space"
  },
  {
    "objectID": "clones/DynamicsSimulations/problem05/README.html",
    "href": "clones/DynamicsSimulations/problem05/README.html",
    "title": "problem05",
    "section": "",
    "text": "5. Read up.\na. Read all of the course Teams posts so far, trying out all possible links of interest.  \nb. Make sure you thoroughly understand these sections of the Ruina/Pratap pdf book, available from Ruina’s www page:  \n   - Chapter 1 (read),\n   - Chapter 2 (skim, only study things you don’t know well already, make sure that within a few weeks you know all of this well. ),\n   - Chapter 3,\n   - Section 17.1,\n   - Appendix A.\nc. Write the following, if true, if not write that which is true:\n   &gt; “I have carefully done some of the reading assigned. That which I don’t understand or agree with, I have posted on the course Piazza site. I haven’t yet carefully read X [make appropriate substitutions for X]”.\n\nI have carefully done some of the reading assigned. That which I don’t understand or agree with, I have discussed in class. I haven’t yet carefully read Chapter 3, Section 17.1, Appendix A."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem03/README.html",
    "href": "clones/DynamicsSimulations/problem03/README.html",
    "title": "problem03",
    "section": "",
    "text": "3. More ODE & animation practice. Take a simple set of ODEs. Use a set you like,e.g., harmonic oscillator, non-linear pendulum, the Lorentz system (look it up on the internet). Solve this set numerically 3 ways (see below), and understand the accuracy. The goal is that, by the time you hand in the homework, you can write and debug the assignment on your own without looking up anything (outside of trivial syntax things). And you always have a good sense of the accuracy of your solution.\na. Method 1: as simply as possible, without ODE45, and without calling functions or anything like that. A single function or script file with no function calls (ok, plotting calls are ok). Just write a simple loop that implements Euler’s method with your ODE.  \nb. With your own Euler solver function. Your main program should call your Euler solver. Your Euler solver should call a RHS (Right Hand Side) function.  \nc. With ODE45.  \nd. Using (b), solve the equations many times with progressively smaller step size, down to the smallest size you have patience for, and up to the largest size that isn’t crazy. As sensibly as possible, compare the results and use that comparison to estimate the accuracy of each solution. You should be able to find a method to estimate the accuracy of a numerical solution even without knowing the exact solution.  \ne. Using ODE45, solve the equations with various accuracies (use ’reltol’ and ’abstol’, note MATLAB satisfies one or the other, whichever is easiest. So, if you want an accurate solution you need to make both ’reltol’ and ’abstol’ small). Does Matlab do a good job of estimating its own accuracy? Use suitable plots to make your point."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem03/README.html#tailmatch-characterisation",
    "href": "clones/DynamicsSimulations/problem03/README.html#tailmatch-characterisation",
    "title": "problem03",
    "section": "TailMatch Characterisation",
    "text": "TailMatch Characterisation\nThe ‘tailmatch’ is quite easily implemented in code, in file ./ODESolvers/src/Benchmarks.jl:\ntail_match(sol1::ProblemTypes.Solution, sol2::ProblemTypes.Solution)::ProblemTypes.AbsError = norm(sol2[end] - sol1[end])\nSince my current implementation saves updated state at each step, benchmarking for progressively reducing step sizes takes a lot of memory on top of time. I will update the euler solver to not save at each time step, benchmark at smaller step sizes later. For now, for the step size, I have gone till 1e-6 and the plot for the benchmark, with tail_match is as follows:\n\n\n\nStep sizes vs AbsError\n\n\nTODO: fix memory issue and go till 1e-15\nI have done some deep (very small) comparision of Midpoint and RK4 in ./problem09/README.md"
  },
  {
    "objectID": "clones/DynamicsSimulations/problem03/README.html#slither-charaterisation",
    "href": "clones/DynamicsSimulations/problem03/README.html#slither-charaterisation",
    "title": "problem03",
    "section": "Slither Charaterisation",
    "text": "Slither Charaterisation\nTo do this, we create some histories with different step sizes. I have skipped this for now."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem01/README.html",
    "href": "clones/DynamicsSimulations/problem01/README.html",
    "title": "problem01",
    "section": "",
    "text": "Set up (define system, draw FBD, write ODEs) a particle problem. Just one particle. 2D or 3D, your choice. Use a force, or forces that you like (gravity, spring, air friction). Any example of interest. Find a numerical solution. Graph it. Animate it. Try to make an interesting observation.\n\n\n\nSystem Description and Free Body Diagram\nI think I have chosen a just hard enough interesting problem. A spring pendulum consists of a mass \\(m\\) attached to a spring of natural length \\(l_0\\) and spring constant \\(k\\).\nThe system experiences: - Spring force \\(\\vec{F_s} = k(\\|{\\vec{r}\\|}-l_0)(-\\hat{r})\\) - Gravitational force \\(\\vec{F_g} = mg(-\\hat{j})\\) - Damping force \\(\\vec{F_d} = cv(-\\hat{v})\\)\n\n\n\nFreebody-diagram\n\n\n\n\nEquations of Motion\nIn Cartesian coordinates, the equations of motion are:\n\\[\\dot{\\vec{r}} = \\vec{v}\\] \\[\\dot{\\vec{v}} = -k(\\|\\vec{r}\\|-l_0) \\hat{r} - c \\vec{v} - mg\\hat{j}\\]\nThe corresponding code for the ODE in file ./SpringPendulum/src/Physics.jl:\nmodule Physics\n\nusing ..Parameters\nusing LinearAlgebra\nusing UnPack\n\nexport spring_pendulum!\n\nfunction spring_pendulum!(du, u, p::Parameters.Param, t)\n    @unpack mass, gravity, stiffness, restinglen, viscosity = p\n\n    r⃗ = u[1:2]\n    v⃗ = u[3:4]\n\n    ĵ = [0.0; 1.0]\n    gravity = mass * gravity * (-ĵ)\n    spring = stiffness * (norm(r⃗) - restinglen) * (-normalize(r⃗))\n    drag = -viscosity * v⃗\n\n    force = (spring + drag + gravity)\n\n    du[1:2] = v⃗\n    du[3:4] = force / mass\nend\n\nend\n\n\nNumerical Solution\nIn file ./SpringPendulum/src/SpringPendulum.jl\nmodule SpringPendulum\n\nusing DifferentialEquations\n\ninclude(\"Parameters.jl\")\ninclude(\"Physics.jl\")\ninclude(\"Visualization.jl\")\n\n# problem setup\nx₀, y₀ = (1, 0)\nr₀ = [x₀;y₀]\nv₀ = [1.0;0.0]\nu₀ = [r₀;v₀]\ntspan = (0.0,25.0)\np = Parameters.Param(m=1,g=1,c=0.0,k=1,l₀=0)\nprob = ODEProblem(Physics.spring_pendulum!, u₀, tspan, p)\n\n# solver\nΔt = 0.001\nsol = solve(prob, saveat=Δt, reltol=1e-6, abstol=1e-6)\n\n# visualize\n# ...\n\nend # module SpringPendulum\n\n\nPhase Space Trajectory\nPlot showing the system evolution in phase space. In file ./SpringPendulum/src/Visualization.jl:\n\n\n\nLeft: Trajectory plot. Right: Theta vs Time\n\n\nCode corresponding to this in file SpringPendulum/src/Visualization.jl:\nfunction plot_trajectory(sol; title=\"Spring Pendulum Trajectory\")\n    a = reduce(hcat, sol.u)'\n    x =  a[:, 1]\n    y = a[:, 2]\n    θ = atan.(a[:, 2], a[:, 1])\n\n    xlimits = (minimum(x)-1, maximum(x)+1)\n    ylimits = (minimum(y)-1, maximum(y)+1)\n\n    trajectory_plot = Figure()\n    trajectory = Axis(trajectory_plot[1, 1],\n        title=title,\n        xlabel=\"X position\",\n        ylabel=\"Y position\",\n        limits=(xlimits, ylimits),\n        aspect=1,\n    )\n    lines!(trajectory, x, y,\n        label=\"Trajectory\",\n    )\n    axislegend(position=:rb)\n\n    trajectory = Axis(trajectory_plot[1, 2],\n        title=\"Theta vs time\",\n        xlabel=\"Time\",\n        ylabel=\"Theta\",\n    )\n    lines!(trajectory, sol.t, θ)\n\n    return trajectory_plot\nend\n\n\nAnimation\nThe following shows the animation for the solution system. The code corresponding to this animation:\n\n\nTODO: add springs to visualise\n\n\n\nSpring Pendulum Motion\n\n\nThe code corresponding to this animation is in file ./SpringPendulum/src/Visualization.jl:\nfunction makie_animation(sol; filename=\"sol_animation.gif\", title=\"Animation\")\n    sol_matrix = reduce(hcat, sol.u)'\n    x =  sol_matrix[:, 1]\n    y = sol_matrix[:, 2]\n    θ = atan.(sol_matrix[:, 2], sol_matrix[:, 1])\n\n    # coarse boundaries, for continuous(interpolated) boundary see: https://docs.sciml.ai/DiffEqDocs/stable/examples/min_and_max/\n    xlimits = (minimum(x)-1, maximum(x)+1)\n    ylimits = (minimum(y)-1, maximum(y)+1)\n\n    time = Observable(0.0)\n\n    x = @lift(sol($time)[1])\n    y = @lift(sol($time)[2])\n\n    # Create observables for line coordinates\n    line_x = @lift([0, $x])\n    line_y = @lift([0, $y])\n\n    animation = Figure()\n    ax = Axis(animation[1, 1], title = @lift(\"t = $(round($time, digits = 1))\"), limits=(xlimits, ylimits), aspect=1)\n\n    scatter!(ax, x, y, color=:red, markersize = 15)\n    lines!(ax, line_x, line_y, color=:black)\n\n    framerate = 30\n    timestamps = range(0, last(sol.t), step=1/framerate)\n\n    record(animation, filename, timestamps;\n            framerate = framerate) do t\n        time[] = t\n    end\n\n    return animation\nend\n\n\nObservations\n\nEnergy exchange between potential and kinetic forms\nDamped oscillations due to viscous friction\nFor some parameters there is weird behaviour at very small scales. This is probably an artifact of the solver and floating point truncations. I was unable to reproduce this, but I had shown this to Professor Andy and Ganesh Bhaiya.\nIncreasing c by a little has a drastic effect\nThe problem was fun to simulate\nJulia was fun to code in: Libraries were ergonomic to use, DifferentialEquations.jl, and Makie.jl\nI noticed only much later that all of the trajectories for when resting length is zero are elipses."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "vishal’s sight",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "clones/DynamicsSimulations/README.html",
    "href": "clones/DynamicsSimulations/README.html",
    "title": "Dynamics",
    "section": "",
    "text": "./problem01\n./problem02\n./problem03\n./problem04\n./problem05\n./problem06\n./problem07\n./problem08\n./problem09 \n\n@vishalpaudel"
  },
  {
    "objectID": "clones/DynamicsSimulations/README.html#problems",
    "href": "clones/DynamicsSimulations/README.html#problems",
    "title": "Dynamics",
    "section": "",
    "text": "./problem01\n./problem02\n./problem03\n./problem04\n./problem05\n./problem06\n./problem07\n./problem08\n./problem09 \n\n@vishalpaudel"
  },
  {
    "objectID": "clones/DynamicsSimulations/problem02/README.html",
    "href": "clones/DynamicsSimulations/problem02/README.html",
    "title": "problem02",
    "section": "",
    "text": "2. \\(\\quad\\) 3D. Get good at vectors. Assume that the positions relative to an origin of four random points, which are randomly located in space are given as \\(\\vec{\\mathbf{r}}_A\\), \\(\\vec{\\mathbf{r}}_B\\), \\(\\vec{\\mathbf{r}}_C\\) and \\(\\vec{\\mathbf{r}}_D\\). Assume force \\(\\vec{\\mathbf{F}}\\) is given. For each problem below write a single vector formula (one for each problem) that answers the question.\na) The points A and B define an infinite line. So do the points C and D. Find the distance between these two lines. ‘The’ distance means ‘the minimum distance’, that is the length of the shortest line segment connecting the two lines. Either write a formula (or sequence of formulas), or write computer code that gives the answer, or both.  \nb) Same problem as above, but also find the end points of the shortest line segment.  \nc) Find the volume of the tetrahedron ABCD (you should reason-out and not quote any formulas for the volume of a tetrahedron, that is, see if you can derive the formula: ’volume = one third base times height’).  \nd) Assume points A, B and C are fixed to a structure. All three are connected, by massless rods, to a ball and socket at each end, to point D. At point D the force  F is applied. Find the tension in bar AD. Find a formula for the answer, or write computer code to find the answer, or both. The goal is to find a formula for the tension in terms of the positions and the force vector.\n\n\nWrite formula or code for the length of the shortest line segment\nThe lines can be represented as:\n\\[l_1: \\vec{p}_1(\\lambda_1) = \\quad \\vec{\\mathbf{r}}_A + \\lambda_1 (\\vec{\\mathbf{r}}_B-\\vec{\\mathbf{r}}_A)\\]\n\\[l_2: \\vec{p}_2(\\lambda_2) = \\quad \\vec{\\mathbf{r}}_C + \\lambda_2 (\\vec{\\mathbf{r}}_D-\\vec{\\mathbf{r}}_C)\\]\nHence, for two points on either lines, \\(p_1\\), \\(p_2\\), the distance is:\n\\[D(\\lambda_1, \\lambda_2) = \\quad \\left|\\left| \\mathbf{\\vec{p}}_2 - \\mathbf{\\vec{p}}_1 \\right|\\right|_n\\]\nWhich can be framed as an optimisation problem, minimum length, \\(\\hat{s}\\):\n\\[\\hat{s} = \\quad \\min_{\\lambda_1, \\lambda_2} || \\left( \\vec{\\mathbf{r}}_A + \\lambda_1 (\\vec{\\mathbf{r}}_B-\\vec{\\mathbf{r}}_A) - (\\vec{\\mathbf{r}}_C + \\lambda_2 (\\vec{\\mathbf{r}}_D-\\vec{\\mathbf{r}}_C)) \\right) ||_n\\]\nor,\n\\[\\hat{s} \\leftarrow D\\left\\{ \\nabla D(\\lambda_1, \\lambda_2) = 0 \\right\\}\\]\nThe code corresponding to this in file ./MinimumDistanceBetweenTwoLines/src/MinimumDistanceBetweenTwoLines.jl is:\nmodule MinimumDistanceBetweenTwoLines\n\nimport Symbolics\nimport LinearAlgebra\n\n# problem setup\nconst N = 3\nSymbolics.@variables r⃗ₛ[1:N] r⃗ₜ[1:N] r⃗ᵤ[1:N] r⃗ᵥ[1:N]\nSymbolics.@variables λ₁ λ₂\n\np⃗₁ = r⃗ₛ + λ₁ * (r⃗ₜ - r⃗ₛ)\np⃗₂ = r⃗ᵤ + λ₂ * (r⃗ᵥ - r⃗ᵤ)\ns⃗ = p⃗₂ - p⃗₁\nD² = LinearAlgebra.dot(s⃗, s⃗)\nD² = Symbolics.scalarize(D²)\n∇D² = Symbolics.gradient(D², [λ₁, λ₂])\neq = ∇D² .~ 0\n\nlambdas_symbolic = Dict([λ₁, λ₂] .=&gt; Symbolics.symbolic_linear_solve(eq, [λ₁, λ₂]))\np̂₁_symbolic, p̂₂_symbolic = Symbolics.substitute.([p⃗₁, p⃗₂], Ref(lambdas_symbolic))\nŝ_symbolic = Symbolics.substitute.(D², Ref(lambdas_symbolic))\n\n#...\nNote that in the code, we are optimising for distance squared, and the \\(s\\) symbols in the code represent the distance squared.\nIn the same file, we take specific values:\n#...\n\n# evaluation\nsubs = Dict(\n    r⃗ₛ =&gt; [0.0, 0.0, 0.0],\n    r⃗ₜ =&gt; [1.0, 0.0, 0.0],\n    r⃗ᵤ =&gt; [0.0, 0.0, 1.0],\n    r⃗ᵥ =&gt; [0.0, 1.0, 2.0],\n    # λ₁ =&gt; 3,\n    # λ₂ =&gt; 4,\n)\n∇D²_eval = Symbolics.substitute.(∇D², Ref(subs))\n\neq_eval = Symbolics.substitute.(eq, Ref(subs))\n\nresult_eval = Dict(symbol =&gt; Symbolics.substitute(expresion, subs) for (symbol, expresion) in lambdas_symbolic)\nmerged_eval = merge(subs, result_eval)\n\nŝ_eval = Symbolics.substitute.(D², Ref(merged_eval))\np̂₁_eval, p̂₂_eval = Symbolics.substitute.([p⃗₁, p⃗₂], Ref(merged_eval))\n\nprintln(\"=== Substituted results: =====\")\nprintln(\"Λ̂  : \", result_eval)\nprintln(\"ŝ  = \", ŝ_eval)\nprintln(\"p̂₁ = \", p̂₁_eval)\nprintln(\"p̂₂ = \", p̂₂_eval)\n\nprintln(\"\\n=== Symbolic results: =====\")\nprintln(\"Λ̂  : \", lambdas_symbolic)\nprintln(\"ŝ  = \", Symbolics.scalarize(ŝ_symbolic))\nprintln(\"p̂₁ = \", Symbolics.scalarize(p̂₁_symbolic))\nprintln(\"p̂̂₂ = \", Symbolics.scalarize(p̂₂_symbolic))\n\nend # module MinimumDistanceBetweenTwoLines\nThis produces the following:\njulia&gt; include(\"src/MinimumDistanceBetweenTwoLines.jl\")\nWARNING: replacing module MinimumDistanceBetweenTwoLines.\n=== Substituted results: =====\nΛ̂  : Dict{Symbolics.Num, Float64}(λ₂ =&gt; -0.5, λ₁ =&gt; -0.0)\nŝ  = 0.5\np̂₁ = [0.0, 0.0, 0.0][Base.OneTo(3)]\np̂₂ = [0.0, -0.5, 0.5][Base.OneTo(3)]\n\n=== Symbolic results: =====\nΛ̂  : Dict{Symbolics.Num, SymbolicUtils.BasicSymbolic{Real}}(λ₂ =&gt; ((-(2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(⃗rₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-⃗rᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), λ₁ =&gt; ((-((-(2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)))\nŝ  = (r⃗ᵤ[1] - r⃗ₛ[1] + ((-r⃗ᵤ[1] + r⃗ᵥ[1])*(((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + (((((-(-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - ⃗rₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(r⃗ₛ[1] - r⃗ₜ[1])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)))^2 + (r⃗ᵤ[2] - r⃗ₛ[2] + (((((-(-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(r⃗ₛ[2] - r⃗ₜ[2])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[2] + r⃗ᵥ[2])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)))^2 + (r⃗ᵤ[3] - r⃗ₛ[3] + ((((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) - 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[3] + r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)))^2\np̂₁ = Symbolics.Num[r⃗ₛ[1] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(⃗rₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[1] + r⃗ₜ[1])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)), r⃗ₛ[2] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - ⃗rₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[2] + r⃗ₜ[2])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)), r⃗ₛ[3] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[3] + r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2))]\np̂̂₂ = Symbolics.Num[r⃗ᵤ[1] + ((-r⃗ᵤ[1] + r⃗ᵥ[1])*(((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-⃗rᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), r⃗ᵤ[2] + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[2] + r⃗ᵥ[2])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), r⃗ᵤ[3] + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2))]\nMain.MinimumDistanceBetweenTwoLines\n\n\nAlso find the end points of the shortest line segment\nThe formulation above can be reused, the optimal lambdas \\(\\hat{\\Lambda} = (\\lambda_1, \\lambda_2)\\), correspond to the closest points through the equation of the lines.\n\\[\\left(\\hat{\\lambda}_1, \\hat{\\lambda}_2\\right) = \\underset{\\lambda_1, \\lambda_2}{\\texttt{argmin}} \\left\\{ D(\\lambda_1, \\lambda_2) \\right\\}\\]\nA specific example’s numerical output was given in the previous section.\n\n\nFind the volume of the tetrahedron\nFor any 2d shape extended to a point, the volume is \\(\\frac{1}{3} \\text{Base-Area} \\times \\text{height}\\). Why? Take a slice, the planar dimensions reduce linearly to zero, so the area reduces quadratically. Integrate the function for the area as a function of the height from base to the tip.\nThis way, we can see that a tetrahedron is geometric one-sixth of a parallelapiped, therefore, volume \\(V(\\vec{\\mathbf{r}}_a, \\vec{\\mathbf{r}}_b, \\vec{\\mathbf{r}}_c, \\vec{\\mathbf{r}}_d)\\) is (assuming the vectors are in three dimensions for cross product to work):\n\\[V(\\vec{\\mathbf{r}}_a, \\vec{\\mathbf{r}}_b, \\vec{\\mathbf{r}}_c, \\vec{\\mathbf{r}}_d) = \\frac{1}{6} \\left|(\\vec{\\mathbf{r}}_c - \\vec{\\mathbf{r}}_b) \\times (\\vec{\\mathbf{r}}_c - \\vec{\\mathbf{r}}_a) \\cdot (\\vec{\\mathbf{r}}_d - \\vec{\\mathbf{r}}_d)\\right|\\]\n\n\nWrite formula or code for the tensions in the rods\n\\[\\vec{\\mathbf{F}} + T_{ad}\\hat{r}_{ad} + T_{bd}\\hat{r}_{bd} + T_{cd}\\hat{r}_{cd} = \\vec{\\mathbf{0}}\\]\nThere was an in-class mention about Cramer’s rule to solve this. There are three equations and three unknowns, but one could use Gaussian-elimination.\nThe other way to solve this using vector algebra is to dot the whole equation with a vector which is perpendicular to two of the three tension vectors. For example by \\(\\hat{r}_{ad}\\)."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem04/README.html",
    "href": "clones/DynamicsSimulations/problem04/README.html",
    "title": "problem04",
    "section": "",
    "text": "4. Cross product: geometry vs components.\na) The geometric definition of crossproduct is this $\\vec{a} \\times \\vec{b}$ is a vector $\\vec{c}$ with magnitude $\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin\\theta_{ab}$ that is orthmorogonal to $\\vec{a}$ and $vec{b}$ in the direction given by the right hand rule. Use this definition to findan alternative geometric definition involving projection (namely: project $\\vec{b}$ onto theplane that is orthogonal to $\\vec{a}$; then stretch it by $\\vec{|a|}$; then rotate it $\\pi/2$ around the $\\vec{a}$ axis). Use that definition to show the distributive rule $\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$.  \nb) Then use the distributive rule to find the component formula for cross product,namely that $\\vec{a} \\times \\vec{b} = (a_2 b_3 − a_3 b_2)\\hat{e}_1 + (a_3 b_1 − a_1 b_3) \\hat{e}_2 + (a_1 b_2 − a_2 b_1)\\hat{e}_3$.  \nNote that, this distributive law implies that, for given \\(va \\times \\vec{v}\\) is a linear operator.That is \\(va \\times \\vec{v}\\) is a linear function fo \\(\\vec{v}\\). Later in the course we will use this to replacethe cross product with a tensor product. Hint: You can read about this in, say, theRuina/Pratap book (box 1.7).\n\nThe cross product \\(\\vec{a} \\times \\vec{b}\\) is defined geometrically as a vector \\(\\vec{c}\\) with magnitude \\(\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin \\theta_{ab}\\), direction orthogonal to both \\(\\vec{a}\\) and \\(\\vec{b}\\), and orientation following the right-hand rule. We can reformulate this using projection. First, project \\(\\vec{b}\\) onto the plane orthogonal to \\(\\vec{a}\\) using the formula \\(\\vec{b}_{\\perp} = \\vec{b} - (\\vec{b}\\cdot\\hat{a})\\hat{a}\\), where \\(\\hat{a}\\) is the unit vector in direction of \\(\\vec{a}\\). The magnitude of this projection is \\(\\|\\vec{b}\\_{\\perp}\\| = \\|\\vec{b}\\|\\sin \\theta\\)\nThen stretch this vector by \\(\\|\\vec{a}\\|\\), giving \\(\\|\\vec{a}\\|\\vec{b}\\_{\\perp}\\) with magnitude \\(\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin \\theta\\). Finally, rotate this vector by \\(\\pi/2\\) around the \\(\\vec{a}\\) axis, which preserves magnitude while making the result orthogonal to both \\(\\vec{a}\\) and \\(\\vec{b}\\_{\\perp}\\) in the right-hand rule direction. This construction yields a vector identical to the original definition.\nTo prove distributivity, \\(\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}\\), we use this new geometric definition. When we project \\((\\vec{b} + \\vec{c})\\) onto the plane perpendicular to \\(\\vec{a}\\), linearity of projection gives us \\((\\vec{b} + \\vec{c})\\_{\\perp} = \\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}\\). Stretching by \\(\\|\\vec{a}\\|\\) is also linear: \\(\\|\\vec{a}\\|(\\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}) = \\|\\vec{a}\\|\\vec{b}\\_{\\perp} + \\|\\vec{a}\\|\\vec{c}\\_{\\perp}\\). Since rotation by \\(\\pi/2\\) is linear, \\(R\\_{\\pi/2}(\\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}) = R\\_{\\pi/2}\\vec{b}\\_{\\perp} + R\\_{\\pi/2}\\vec{c}\\_{\\perp}\\), proving the distributive property.\nTo derive the component formula, we use distributivity: \\(\\vec{a} \\times \\vec{b} = (a\\_1\\hat{e}\\_1 + a\\_2\\hat{e}\\_2 + a\\_3\\hat{e}\\_3) \\times (b\\_1\\hat{e}\\_1 + b\\_2\\hat{e}\\_2 + b\\_3\\hat{e}\\_3) = \\sum\\_{i,j} a\\_ib\\_j(\\hat{e}\\_i \\times \\hat{e}\\_j)\\). Using the standard basis cross products (\\(\\hat{e}\\_1 \\times \\hat{e}\\_2 = \\hat{e}\\_3\\), \\(\\hat{e}\\_2 \\times \\hat{e}\\_3 = \\hat{e}\\_1\\), \\(\\hat{e}\\_3 \\times \\hat{e}\\_1 = \\hat{e}\\_2\\), \\(\\hat{e}\\_i \\times \\hat{e}\\_i = 0\\), \\(\\hat{e}\\_j \\times \\hat{e}\\_i = -(\\hat{e}\\_i \\times \\hat{e}\\_j)\\)), we expand and group terms to get the final component formula: \\(\\vec{a} \\times \\vec{b} = (a\\_2b\\_3 - a\\_3b\\_2)\\hat{e}\\_1 + (a\\_3b\\_1 - a\\_1b\\_3)\\hat{e}\\_2 + (a\\_1b\\_2 - a\\_2b\\_1)\\hat{e}\\_3\\)."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem06/README.html",
    "href": "clones/DynamicsSimulations/problem06/README.html",
    "title": "problem06",
    "section": "",
    "text": "6. Spring and mass (2D). One end of of a negligible-mass spring (k, L0) is pinned to the origin, the other to a mass (m). There is gravity (g). Initial Conditions (ICs): The initial position is \\(\\vec{r}\\_0 = x\\_0\\hat{i} + y\\_0\\hat{j}\\), and the initial velocity is \\(\\vec{v}\\_0 = v\\_{x0}\\hat{i} + v\\_{y0}\\hat{j}\\). Motion starts at \\(t = 0\\) and ends at tend.\n(a) Find the Equations of Motion (EoM);  \n(b) Assume all parameters and IC’s above are given.  \n    i. Plot the trajectory of the mass.  \n    ii. Animate the trajectory of the mass.  \n(c) How many ways can you think of checking the numerical solution, find as manyas you can, and do the check. The list is started here:\n    i. k = 0, all else arbitrary: The motion is parabolic flight (including fallingstraight down as a special case) [Why? The system is then just ballisticsfrom freshman physics];\n    ii. x0 = 0, vx0 = 0, all else arbitrary: The motion stays on the y axis [Why?There is no force in the x direction if the mass is on the y axis. Becausethe initial velocity has no x component, the mass never leaves the y axis;\n    iii. g = 0,*v0 =*0, all else is arbitrary: The motion stays on a radial line. And,if the motion does not cross the origin, the motion is that of a harmonicoscillator (sinusoidal oscillations, check by plotting, say x vt t. [Why? Writethe EoM and EoMs in polar coordinates⇒ mr¨ = −k(r − L0) ⇒ the harmonic oscillator equation, mr¨∗ =−kr∗, where r∗ ≡ r − L0.\n    iv. L0 = 0, all else is arbitrary: ? . [Why? ? .] Hint, this onespecial case is problem 10, below.v. etc.vi. etc.vii. . . .  \n\nSince I already did all of this pretty much in problem 1. I will instead write a simple lorentz system and animate it here.\nIn file ./lorentz_system.jl:\nusing DifferentialEquations\nusing GLMakie\n\n# ----------------------------\n# Define the Lorenz System\n# ----------------------------\n# The Lorenz system is given by:\n#   dx/dt = σ (y - x)\n#   dy/dt = x (ρ - z) - y\n#   dz/dt = x y - β z\nfunction lorenz!(du, u, p, t)\n    σ, ρ, β = p\n    du[1] = σ * (u[2] - u[1])\n    du[2] = u[1] * (ρ - u[3]) - u[2]\n    du[3] = u[1] * u[2] - β * u[3]\nend\n\n# ----------------------------\n# Set Parameters, Initial Conditions, and Solve the ODE\n# ----------------------------\n# Typical parameter values for the Lorenz system:\np = (10.0, 28.0, 8/3)\nu0 = [1.0, 0.0, 0.0]  # initial condition\ntspan = (0.0, 40.0)   # simulation time\n\n# Set up the ODE problem and solve it.\nprob = ODEProblem(lorenz!, u0, tspan, p)\nsol = solve(prob, Tsit5(); saveat=0.01)\n\n# ----------------------------\n# Create the Animation with Makie\n# ----------------------------\n# Create a new scene with a 3D camera.\nscene = Scene(resolution = (800, 600), camera = campixel!)\n\n# Plot the full trajectory as a blue line.\nlines!(scene, sol[1, :], sol[2, :], sol[3, :],\n       color = :blue, linewidth = 1)\n\n# Initialize a red marker for the moving point.\n# We start with the first position.\npoint = scatter!(scene, [sol[1,1]], [sol[2,1]], [sol[3,1]],\n                 markersize = 15, color = :red)\n\n# Record the animation. Here, each frame updates the position of the point.\nrecord(scene, \"lorenz_animation.gif\", length(sol.t)) do i\n    # Update the marker position to the i-th solution point.\n    point[1].attributes[:positions][] = Point3f0(sol[1,i], sol[2,i], sol[3,i])\n    # Optionally, you can adjust the frame rate by pausing briefly:\n    sleep(0.001)\nend\n\nprintln(\"Animation saved as lorenz_animation.gif\")\nThis produces the following animation:\n\n\n\n../media/problem06/lorentz_attractor.gif\n\n\nIs there a way to think about verifying lorentz system solutions? I haven’t thought through this yet."
  },
  {
    "objectID": "clones/DynamicsSimulations/problem08/README.html",
    "href": "clones/DynamicsSimulations/problem08/README.html",
    "title": "problem08",
    "section": "",
    "text": "Simplest dynamics with Polar coordinates. This is the simplest dynamics problem, but posed in polar coordinates. Assume a particle is on a plane with no force on it. So, you know it moves at constant speed in a constant direction.\n\nWrite the differential equations \\(\\vec{a} = \\vec{0}\\) in polar coordinates.\nSolve them numerically for various initial conditions.\nPlot the solution and check that the motion is a straight line at constant speed.\nUsing your numerical result, pick a way to measure how straight the path is, and see how straight a line your polar coordinate solution gives. You should define a quantitative measure of straightness, and then measure it with your solution. e. Is the path more straight when you refine the numerical tolerances.\n\n\n\n\na. Write differential equations in polar form\nWe finally get:\n\\[\\vec{a} = (\\ddot{r} - r\\omega^2)\\hat{e}_r + (2\\dot{r}\\omega + r\\dot{\\omega})\\hat{e}_\\theta = \\vec{0}\\]\nWe can break this down into two scalar differential equations of non-unity order,\n\\[ \\ddot{r} - r\\omega^2 = 0 \\]\n\\[ 2\\dot{r}\\omega + r \\dot{\\omega} = 0 \\]\nRearranging the terms\n\\[ \\ddot{r} =  r\\omega^2 \\]\n\\[ \\dot{\\omega} = - 2r^{-1}v_r\\omega \\]\nintroducing the state variable in the following way to reduce this into a first order vector differential equation, also we include \\(\\theta\\) to able to track it:\n\\[\\vec{z} =\n\\begin{bmatrix}\n    \\dot{r} \\\\\n    \\dot{v_r} \\\\\n    \\dot{\\theta} \\\\\n    \\dot{\\omega}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    v_r \\\\\n    r\\omega^2 \\\\\n    \\omega \\\\\n    - 2r^{-1}v_r\\omega \\\\\n\\end{bmatrix}\n\\]\nThe corresponding code for this ODE in file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Physics: ODE\nfunction aceleration_zero_polar!(du, u, p, t)\n    r  = u[1]\n    vᵣ = u[2] \n    θ  = u[3]\n    ω  = u[4]\n\n    du[1] = vᵣ\n    du[2] = r * ω^2\n    du[3] = ω\n    du[4] = -2 * r^(-1) * vᵣ * ω\nend\n\n\nb. Solve them numerically for various initial conditions\nSome trajectories and some animations for various initial sets of initial conditions look indeed like uniform motion.\nIn file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n # Problem setup\nr₀ = 2\nθ₀ = π/3\nv⃗ = [1;2]\n\nêᵣ = [cos(θ₀); sin(θ₀)]\nêₚ = [-sin(θ₀); cos(θ₀)]\n\nvᵣ₀ = dot(v⃗, êᵣ)\nvₚ₀ = dot(v⃗ - vᵣ₀ * êᵣ, êₚ)\n\nω₀ = vₚ₀ / r₀\n\nu₀ = [r₀; vᵣ₀; θ₀; ω₀]\ntspan = (0.0, 10.0)\np = nothing\n\nprob = ODEProblem(acceleration_zero_polar!, u₀, tspan, p)\n\n# Numerical solution\nΔh = 0.5\nsol = solve(prob, saveat=Δh, abstol=1, reltol=1)\n\n\nc. Plot the solution and check that the motion is a straight line at constant speed.\nIn file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Plotting trajectories\nfunction plot_trajectory_makie(sol)\n    # Convert solution to matrix form\n    sol_matrix = reduce(hcat, sol.u)'\n    \n    r = sol_matrix[:, 1]\n    θ = sol_matrix[:, 3]\n\n    r⃗ = r .* [cos.(θ) sin.(θ)]\n    x = r⃗[:, 1]\n    y = r⃗[:, 2]\n    xlimits = (minimum(x)-5, maximum(x)+5)\n    ylimits = (minimum(y)-5, maximum(y)+5)\n\n    ω = sol_matrix[:, 4]\n    vᵣ = sol_matrix[:, 2]\n    vₚ = ω .* r\n    v⃗ = [vᵣ vₚ]\n    s = norm.([v⃗[i, :] for i in 1:length(length(v⃗))])\n    t = sol.t\n    println(typeof(v⃗), size(v⃗), size(t), v⃗)\n\n    # Create figure\n    fig = GLMakie.Figure()\n    ax1 = GLMakie.Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\", limits=(xlimits, ylimits), aspect = DataAspect())\n    ax2 = GLMakie.Axis(fig[1, 2], xlabel=\"time\", ylabel=\"speed\", aspect = DataAspect())\n\n    GLMakie.lines!(ax1, x, y)\n    GLMakie.lines!(ax2, t, s)\n    GLMakie.save(\"problem08-trajectory.png\", fig)\n    GLMakie.display(fig)\n    return nothing\nend\nplot_trajectory_makie(sol)\nThe plots generated by this:\n\n\n\nTrajectory\n\n\nLeft: The position of particle, \\(x\\) vs \\(y\\), Right: The speed of particle, \\(\\|\\vec{v}\\|\\) vs \\(t\\)\n\n\nd. Define a metric to measure straightness, plot\nJust like problem03, we can either use an analog to slither, i.e. the root mean squared error, but that again would require a lot of computer memory, which corresponds to impossibility on my computer, hence the easiest way here is the tail_match.\nThe measure here is the euclidean norm from the expected end point:\n\\[\\mathbf{\\hat{p}} = r_0\\left(cos(\\theta_0)\\hat{i} + sin(\\theta_0)\\hat{j}\\right) + \\vec{v} \\Delta t\\]\n\\[e = \\texttt{norm}(\\mathbf{\\vec{p}}-\\mathbf{\\hat{p}})\\]\nThe code corresponding to this, in file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Measuring straightness\nfunction norm_expected_straight_endpoint(p⃗)\n    Δt = tspan[2] - tspan[1]\n    v⃗_cartesian = vᵣ₀ .* êᵣ₀ + vₚ₀ .* êₚ₀\n    p̂ = r₀ .* [cos(θ₀); sin(θ₀)] .+ v⃗_cartesian .* Δt\n    s⃗ = p⃗ .- p̂\n    e = norm(s⃗)\n    return e\nend\nThe path is already very straight without refining \\(\\Delta h\\):\n\n\n\nError vs Step size\n\n\nThis sums up my attempt of problem08."
  }
]