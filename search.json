[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gyan’s sight",
    "section": "",
    "text": "This is Gyan’s PKM Sight.\n\n\n\n\n\nPKM (personal knowlege management)\n\n\n\n\n\n\n\n\n\nExpand To Learn About Gyan\n\n\n\n\n\nGyan (@haxfn), is a creator therefore a learner.\n\n\n\n\n\n\n\n\n\nExpand to Learn About this Site\n\n\n\n\n\nSight (site), is a presentation of Gyan’s Sight."
  },
  {
    "objectID": "content/Resources/materials/ocaml/index.html",
    "href": "content/Resources/materials/ocaml/index.html",
    "title": "OCaml",
    "section": "",
    "text": "OCaml Programming: Correct+Efficient+Beautiful\n\nWebsite Course Video Book\n\n\n\nMeta",
    "crumbs": [
      "Materials",
      "OCaml"
    ]
  },
  {
    "objectID": "content/Resources/materials/clang/index.html",
    "href": "content/Resources/materials/clang/index.html",
    "title": "Clang",
    "section": "",
    "text": "Advanced C\n\n\n\n\n\n\nPart 1\n\n\n\n\n\n\n// function pointers in clang\n\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint foo(int num1, int num2) { return num1 + num2; }\n\nbool iseven(int numer) {\n  int mod2 = (numer % 2);\n  int isdivisiblebytwo = mod2 == 0;\n  return isdivisiblebytwo;\n}\n\nbool all(int _) {\n  return true;\n}\n\n#define ARRSIZE 10\nvoid printif(const int xes[ARRSIZE], bool (*predicate)(int)) {\n  printf(\"[\");\n  for (int i = 0; i &lt; ARRSIZE; i++) {\n    int ith = xes[i];\n    if (predicate(ith)) {printf(\"%i\", ith); if(i+1!=ARRSIZE) printf(\", \");}\n  }\n  printf(\"];\\n\");\n}\n\nvoid swap(int* foo, int* bar) {\n  int temp = *foo;\n  *foo = *bar;\n  *bar = temp;\n}\n\nvoid shuffle_(int newarr[ARRSIZE], const int arr[ARRSIZE]) {\n    // int newarr[ARRSIZE] = {};\n    int prevj = 1;\n    for(int i=0;i&lt;ARRSIZE;++i) {\n      newarr[i] = arr[i];\n    }\n\n    for(int i=0;i&lt;ARRSIZE;++i) {\n      prevj = (newarr[(i+prevj)%ARRSIZE])%(ARRSIZE);\n      swap(&newarr[i], &newarr[prevj]);\n    }\n}\n\nvoid map(int arr[ARRSIZE], int (*func)(int)) {\n  for(int i = 0; i &lt; ARRSIZE; ++i) {arr[i] = func(i);}\n}\n\nint compareint(const void *int1, const void *int2) {\n  int diff = *((int*)int1)-*((int*)int2);\n  return diff;\n}\n\nint main(void) {\n  int xes[ARRSIZE] = {1,2,3,4,5,6,7,8,9,10};\n\n  // Adding\n  printf(\"= Adding\\n\");\n  int (*func1)(int, int) = foo;\n  int res1 = func1(xes[0], xes[1]);\n  printf(\"%i\\n\", res1);\n\n  // printif(xes, iseven);\n  printf(\"= printif(..., even)\\n\");\n  bool (*func2)(int) = iseven;\n  printif(xes, func2);\n\n  // shuffling\n  printf(\"= Shuffling\\n\");\n  int shuffled[ARRSIZE] = {};\n  shuffle_(shuffled, xes);\n  printif(xes, all);\n  printif(shuffled, all);\n\n  // quicksort\n  printf(\"= Sorted\\n\");\n  qsort(xes, ARRSIZE, sizeof(int), compareint);\n  printif(xes, all);\n}\n\n\n\n\n\n\n\n\n\nPart 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeta\n\n\n\n\n\nThis is a Playlist created by Charles Cabergs.\n\n\n\n\n\nThe C Programming Language 2Ed\n\n\n\n\n\n\nNote\n\n\n\n\n\nAssignment is an expression with the value of the LHS. One consequence: a = b = c = 1 is equivalent to a = (b = (c = 1)).\n\n\n\n\n\n\n\n\n\nChapter 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeta\n\n\n\n\n\n\n\n\nPDF Book\n\n\n\n\n\n\n\nMeta\n\nExplain clang Syntax in Plain English",
    "crumbs": [
      "Materials",
      "Clang"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem20/index.html",
    "href": "content/DynamicsSimulations/solutions/problem20/index.html",
    "title": "problem20",
    "section": "",
    "text": "20. Two masses. This problem has 3 independent educational goals:\n\nMotivate the use of kinematic constraints.\nIntroduce the simplest of a class of vibrations problems which you should master. At this point, it is this aspect: mastery of derivation of the equations of motion. You should check that you can reproduce the lecture example with no sign errors without looking up anything.\nDevelopment of critical exploration using analytical and numerical methods.\n\nTwo masses \\(m_1\\) and \\(m_2\\) are constrained to move frictionlessly on the x axis. Initially they are stationary at positions \\(x_1(0) = 0\\) and \\(x_2(0) = \\ell_0\\). They are connected with a linear spring with constant k and rest length \\(\\ell_0\\). A rightwards force is applied to the second mass. It is a step, or ‘[Heaviside](https://en.wikipedia.org/wiki/Heaviside_step_function]’ function\n\\[\nF(t) = F_0H(t) = \\begin{cases}\n  0 & \\texttt{, if } t &lt; 0 \\\\\n  F_0 & \\texttt{, if } t \\ge 0\n\\end{cases}\n\\]\n\nWrite code to calculate, plot and (optionally) animate the motions for arbitrary values of the given constants.\nWithin numerical precision, should your numerical solution always have the property that \\(F = (m_1 + m_2) a_G\\) where \\(x_G = (x_1 m_1 + x_2 m_2)/(m_1 + m_2)\\)? (As always in this course, “yes and no” questions aare not multiple choice, but need justification that another sutdent, one who got the opposite answer as you, would find convincing.)\nUse you numerics to demonstrate that if \\(k\\) is large the motion (displacement relative to its starting postion) of each mass is, for time scales large compared to the oscillations, close to the cneter of mass motion.\n5730 only: Using analytical arguments, perhaps inspired by and buttressed with numerical examples, make the following statement as precise as possible:\nFor high values of \\(k\\) the system nearly behaves like a single mass.\n\nOf course, in detail, the system has 2 degrees of freedom (DOF). So you are looking for a way to measure the extent to which the system acts like it has 1 DOF, and in which conditions (for which extreme values of parameters and times) the system is close to 1 DOF by that measure. There is not a simple single unique answer to this question.",
    "crumbs": [
      "Solutions",
      "problem20"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem18/index.html",
    "href": "content/DynamicsSimulations/solutions/problem18/index.html",
    "title": "problem18",
    "section": "",
    "text": "18. Konig’s Theorem. The total kinetic energy of a system of particles is\n\\[E_K = \\frac{1}{2} \\sum m_i v_i^2\\]\n\nDerive an expression of this form\n\n\\[E_K = \\frac{1}{2} m_{tot} v_G^2 + \\texttt{..you fill in the rest}\\]\n\nIs it always true that\n\n\\[(\\sum \\vec{F}^{ext})\\cdot\\vec{v}_{G} = \\frac{d}{dt} (\\frac{1}{2} m_{tot} v_G^2) \\texttt{?}\\]\nDefend your answer with unassailable clear reasoning (that is, a proof or a counter example)\n\nIs it always true that the power of internal forces is equal to the rate of change of the quantity you filled in part (a) above (just the second half of the full expression)? Provide a proof or a counter-example. (A good solution is expected from those in 5730).",
    "crumbs": [
      "Solutions",
      "problem18"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem16/index.html",
    "href": "content/DynamicsSimulations/solutions/problem16/index.html",
    "title": "problem16",
    "section": "",
    "text": "16. Mechanics of two or more particles\n\nFor two unequal particles with mass \\(m_1\\) and \\(m_2\\) what is the period of circular motion if the distance between the particles is \\(d\\) and the only force is the force between them is from classical inverse-square Newtonian gravity, \\(F = Gm_1m_2/r^2\\)?\nPick numbers for \\(G\\), \\(m_1\\), \\(m_2\\) and \\(r\\) and, using appropriate initial conditions, test your analytical result with a numerical simulation. Make any plots needed to make the agreement of your numerical and analytical results convincing.\nFor three equal particles, \\(m_1 = m_2 = m_3 = 1\\) and \\(G = 10\\) what is the angular speed for circular motion on a circle with diameter of \\(d = 3\\)?\nCheck your result for three particles with a numerical simulation, as you did for 2 particles, above.",
    "crumbs": [
      "Solutions",
      "problem16"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem14/index.html",
    "href": "content/DynamicsSimulations/solutions/problem14/index.html",
    "title": "problem14",
    "section": "",
    "text": "What means “rate of change of angular momentum”? Consider a moving particle P. Consider also a moving point C (moving relative to a Newtonian frame \\(\\mathcal{F}\\) that has an origin 0). For which of these definitions of \\(\\vec{H}_{/C}\\) Is the following equation of motion true (that is, consistent with \\(\\vec{F} = m \\cdot \\vec{a}\\))? \\[\\vec{M}_C = \\dot{\\vec{H}}_{/C}\\]\nIn each case say whether the definition works i) in general, or ii) for some special cases (that you name) concerning the motions of P and C.\n\n\\(\\vec{H}_{/C} = \\vec{r}_{P/C'} \\times \\vec{v}_{P/0} m\\), where C’ is a point fixed in \\(\\mathcal{F}\\) that instantaneuosly coincides with C.\n\\(\\vec{H}_{/C} = \\vec{r}_{P/C} \\times \\vec{v}_{P/0} m\\).\n\\(\\vec{H}_{/C} = \\vec{r}_{P/C} \\times \\vec{v}_{P/C} m\\).\n\nThat is, for each possible definition of \\(\\vec{H}_{/C}\\) you need to calculate \\(\\dot{\\vec{H}}_{C}\\) by differentiation and see if and when you get \\(\\dot{\\vec{H}}_{/C} = \\vec{r}_{P/C} \\times m \\vec{a}_{P/\\mathcal{F}}\\)",
    "crumbs": [
      "Solutions",
      "problem14"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem12/index.html",
    "href": "content/DynamicsSimulations/solutions/problem12/index.html",
    "title": "problem12",
    "section": "",
    "text": "12. Canon ball 2. A cannon ball \\(m\\) is launched at angle \\(\\theta\\) and speed \\(v_0\\). It is acted on by gravity \\(g\\) and a quadratic drag with magnitude \\(\\|cv^2\\|\\).\n\nFind a numerical solution using \\(\\theta = \\pi/4\\), \\(v_0 = 1\\) m/s, \\(g = 1\\) m/s\\(^2\\), \\(m = 1\\) kg.\nNumerically calculate (by integrating \\(\\dot{W} = P\\) along with the state variables) the work done by the drag force. Compare this with the change of the total energy. Make a plot showing that the difference between the two goes to zero as the integration gets more and more accurate.\n\n\n\n\n(a) Find a numerical solution using \\(\\theta = \\pi/4\\), \\(v_0 = 1\\) m/s, \\(g = 1\\) m/s\\(^2\\), \\(m = 1\\) kg.\nTaking also \\(c=1\\). The solution comes out to be:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    u = zeros((4,))\n    u[1] = vx0 * (-c/m) * (exp((-c/m)*(t-t0)) - 1)\n    u[2] = ((vy0+(m*g/c))*(-c/m)*(exp((-c/m)*(t-t0)) - 1)) + ((-m*g/c)*(t-t0))\n    u[3] = (vx0) * (exp((-c/m)*(t-t0)))\n    u[4] = ((vy0) + (m*g/c)) * exp((-c/m)*(t-t0)) - (m*g/c)\n\n    return u\nend\n\n\n(b) Numerically calculate (by integrating \\(\\dot{W} = P\\) along with the state variables) the work done by the drag force. Compare this with the change of the total energy. Make a plot showing that the difference between the two goes to zero as the integration gets more and more accurate.\nI take this oppurtunity to implement the ‘slither’ for trajectory similarity, that was introduced in problem03:\nmodule BallisticDrag\n\nimport DifferentialEquations\nimport LinearAlgebra\nimport GLMakie\n\n@kwdef struct Parameters\n    m::Float64\n    g::Float64\n    c::Float64\nend\n\nfunction myode!(du, u, p, t)\n    r = u[1:2]\n    v = u[3:4]\n    vcap = v / LinearAlgebra.norm(v)\n\n    j = [0;1]\n    gravity = (p.m*p.g)*(-j)\n    drag = abs(p.c*LinearAlgebra.dot(v, v))*(-vcap)\n    F = gravity+drag\n    a = F / p.m\n\n    drag_power = LinearAlgebra.dot(drag, v)\n\n    du[1:2] = v\n    du[3:4] = a\n    du[5] = drag_power\nend\n\np = Parameters((global m=1), (global g=1), (global c=1))\ntspan = (0.0, (global tend=10.0))\nu0 = [0.0;0.0;10.0;10.0;0.0]\nodeprob = DifferentialEquations.ODEProblem(myode!, u0, tspan, p)\n\nfunction tae_diff(tolerance)\n    sol = (DifferentialEquations.solve(odeprob; abstol=tolerance, reltol=tolerance))\n    tpoints = length(sol.t)\n\n    sol = reduce(hcat, sol.u)'\n\n    work = sol[:, 5]\n    work_change = work[2:end] .- work[1:end-1]\n\n    v = sol[:, 3:4]\n    kinetic = (1/2)*(m)*([LinearAlgebra.dot(v[i, :], v[i, :]) for i in 1:size(v, 1)])\n    y = sol[:, 2]\n    potential = (m*g)*y\n    total = kinetic .+ potential\n    change = total[2:end] .- total[1:end-1]\n\n    return sum(abs.(change .- work_change)) # / tpoints\nend\n\n# Plot (energy - workdone) TAE (total absolute error) with increasing accuracies\npowers = -range(6, 12)\ntolerances = 10.0.^powers\ntae_energy_change = tae_diff.(tolerances)\n\nfig = GLMakie.Figure()\nax = GLMakie.Axis(fig[1,1], title=\"log(Tolerance) vs Total Energy Change minus Drag Work Done\")\nGLMakie.lines!(ax, powers, tae_energy_change)\nGLMakie.save(\"tolerances_vs_total_energy_change_minus_drag_work_done.png\", fig)\nGLMakie.display(fig)\n\nend # module BallisticDrag\nThis produces the following graph:\n\nThis concludes my attempt of problem12.",
    "crumbs": [
      "Solutions",
      "problem12"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem10/index.html",
    "href": "content/DynamicsSimulations/solutions/problem10/index.html",
    "title": "problem10",
    "section": "",
    "text": "10. Mass hanging from spring. 3D. Consider a point mass hanging from a zero-restlength linear spring (`0 = 0) in a constant gravitational field.\na) Set up equations. Set up for numerical solution. Plot 2D projection of 3D trajectories.\nb) By playing around with initial conditions, find the most wild motion you can find (wild means most wiggles, or most complicated). Make one or more revealing plots. [Hint: Make sure the features you observe are properties of the system and not due to numerical errors. That is, check that the features do not change when the numerics is refined.]\nc) Using analytical methods justify your answer to part (b).\n\n\n\n../../media/problem10/problem10.png\n\n\n\n\na. Plot 2D projection of 3D trajectories\nIn file ./SpringPendulum3D/src/Physics.jl\nfunction spring_pendulum3d!(du, u, p::Parameters.Param, t)\n    @unpack mass, gravity, stiffness, restinglen#=, viscosity=# = p\n\n    r⃗ = u[1:3]\n    v⃗ = u[4:6]\n\n    k = [0.0; 0.0; 1.0]\n    gravity = mass * gravity * (-k)\n    spring = stiffness * (norm(r⃗) - restinglen) * (-normalize(r⃗))\n    # drag = -viscosity * v⃗\n\n    force = (spring #=+ drag =#+ gravity)\n\n    du[1:3] = v⃗\n    du[4:6] = force / mass\nend\nThe 3D trajectories look like ellipses. For a particular set of parameters, given in the following\n\n\n\n../../media/problem10/trajectory_plot.png\n\n\n# ...\n\n# problem setup\nx₀, y₀, z₀ = (1, 0, 0)\nr₀ = [x₀; y₀; z₀]\nv₀ = [0.0; 1.0; 0.0]\nu₀ = [r₀; v₀]\ntspan = (0.0, 10.0)\np = Parameters.Param(m = 1, g = 1, k = 2, l₀ = 0)\nprob = ODEProblem(Physics.spring_pendulum3d!, u₀, tspan, p)\n\n# ...\nThe 2D projection onto the xy, yz, zx respectively, are as follows:\n\n\n\n../../media/problem10/trajectory_plot_projection.png\n\n\n\n\nb. Play around with initial conditions, and find the most wild motions\nI was not able to find any wild motions, other than numerical errors.\n\n\nc. Analytically justify answer to part (b)\nIf we look at the differential equations, it is equivalent to having three independent springs in the three mutually orthogonal directions with a constant shift in the ‘z-spring’ due to gravity.",
    "crumbs": [
      "Solutions",
      "problem10"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem08/index.html",
    "href": "content/DynamicsSimulations/solutions/problem08/index.html",
    "title": "problem08",
    "section": "",
    "text": "8. Simplest dynamics with Polar coordinates. This is the simplest dynamics problem, but posed in polar coordinates. Assume a particle is on a plane with no force on it. So, you know it moves at constant speed in a constant direction. a. Write the differential equations \\(\\vec{a} = \\vec{0}\\) in polar coordinates. b. Solve them numerically for various initial conditions. c. Plot the solution and check that the motion is a straight line at constant speed. d. Using your numerical result, pick a way to measure how straight the path is, and see how straight a line your polar coordinate solution gives. You should define a quantitative measure of straightness, and then measure it with your solution. e. Is the path more straight when you refine the numerical tolerances.\n\n\na. Write differential equations in polar form\nWe finally get:\n\\[\\vec{a} = (\\ddot{r} - r\\omega^2)\\hat{e}_r + (2\\dot{r}\\omega + r\\dot{\\omega})\\hat{e}_\\theta = \\vec{0}\\]\nWe can break this down into two scalar differential equations of non-unity order,\n\\[ \\ddot{r} - r\\omega^2 = 0 \\]\n\\[ 2\\dot{r}\\omega + r \\dot{\\omega} = 0 \\]\nRearranging the terms\n\\[ \\ddot{r} =  r\\omega^2 \\]\n\\[ \\dot{\\omega} = - 2r^{-1}v_r\\omega \\]\nintroducing the state variable in the following way to reduce this into a first order vector differential equation, also we include \\(\\theta\\) to able to track it:\n\\[\\vec{z} =\n\\begin{bmatrix}\n    \\dot{r} \\\\\n    \\dot{v_r} \\\\\n    \\dot{\\theta} \\\\\n    \\dot{\\omega}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    v_r \\\\\n    r\\omega^2 \\\\\n    \\omega \\\\\n    - 2r^{-1}v_r\\omega \\\\\n\\end{bmatrix}\n\\]\nThe corresponding code for this ODE in file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Physics: ODE\nfunction aceleration_zero_polar!(du, u, p, t)\n    r  = u[1]\n    vᵣ = u[2] \n    θ  = u[3]\n    ω  = u[4]\n\n    du[1] = vᵣ\n    du[2] = r * ω^2\n    du[3] = ω\n    du[4] = -2 * r^(-1) * vᵣ * ω\nend\n\n\nb. Solve them numerically for various initial conditions\nSome trajectories and some animations for various initial sets of initial conditions look indeed like uniform motion.\nIn file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n # Problem setup\nr₀ = 2\nθ₀ = π/3\nv⃗ = [1;2]\n\nêᵣ = [cos(θ₀); sin(θ₀)]\nêₚ = [-sin(θ₀); cos(θ₀)]\n\nvᵣ₀ = dot(v⃗, êᵣ)\nvₚ₀ = dot(v⃗ - vᵣ₀ * êᵣ, êₚ)\n\nω₀ = vₚ₀ / r₀\n\nu₀ = [r₀; vᵣ₀; θ₀; ω₀]\ntspan = (0.0, 10.0)\np = nothing\n\nprob = ODEProblem(acceleration_zero_polar!, u₀, tspan, p)\n\n# Numerical solution\nΔh = 0.5\nsol = solve(prob, saveat=Δh, abstol=1, reltol=1)\n\n\nc. Plot the solution and check that the motion is a straight line at constant speed.\nIn file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Plotting trajectories\nfunction plot_trajectory_makie(sol)\n    # Convert solution to matrix form\n    sol_matrix = reduce(hcat, sol.u)'\n    \n    r = sol_matrix[:, 1]\n    θ = sol_matrix[:, 3]\n\n    r⃗ = r .* [cos.(θ) sin.(θ)]\n    x = r⃗[:, 1]\n    y = r⃗[:, 2]\n    xlimits = (minimum(x)-5, maximum(x)+5)\n    ylimits = (minimum(y)-5, maximum(y)+5)\n\n    ω = sol_matrix[:, 4]\n    vᵣ = sol_matrix[:, 2]\n    vₚ = ω .* r\n    v⃗ = [vᵣ vₚ]\n    s = norm.([v⃗[i, :] for i in 1:length(length(v⃗))])\n    t = sol.t\n    println(typeof(v⃗), size(v⃗), size(t), v⃗)\n\n    # Create figure\n    fig = GLMakie.Figure()\n    ax1 = GLMakie.Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\", limits=(xlimits, ylimits), aspect = DataAspect())\n    ax2 = GLMakie.Axis(fig[1, 2], xlabel=\"time\", ylabel=\"speed\", aspect = DataAspect())\n\n    GLMakie.lines!(ax1, x, y)\n    GLMakie.lines!(ax2, t, s)\n    GLMakie.save(\"problem08-trajectory.png\", fig)\n    GLMakie.display(fig)\n    return nothing\nend\nplot_trajectory_makie(sol)\nThe plots generated by this:\n\n\n\nTrajectory\n\n\nLeft: The position of particle, \\(x\\) vs \\(y\\), Right: The speed of particle, \\(\\|\\vec{v}\\|\\) vs \\(t\\)\n\n\nd. Define a metric to measure straightness, plot\nJust like problem03, we can either use an analog to slither, i.e. the root mean squared error, but that again would require a lot of computer memory, which corresponds to impossibility on my computer, hence the easiest way here is the tail_match.\nThe measure here is the euclidean norm from the expected end point:\n\\[\\mathbf{\\hat{p}} = r_0\\left(cos(\\theta_0)\\hat{i} + sin(\\theta_0)\\hat{j}\\right) + \\vec{v} \\Delta t\\]\n\\[e = \\texttt{norm}(\\mathbf{\\vec{p}}-\\mathbf{\\hat{p}})\\]\nThe code corresponding to this, in file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Measuring straightness\nfunction norm_expected_straight_endpoint(p⃗)\n    Δt = tspan[2] - tspan[1]\n    v⃗_cartesian = vᵣ₀ .* êᵣ₀ + vₚ₀ .* êₚ₀\n    p̂ = r₀ .* [cos(θ₀); sin(θ₀)] .+ v⃗_cartesian .* Δt\n    s⃗ = p⃗ .- p̂\n    e = norm(s⃗)\n    return e\nend\nThe path is already very straight without refining \\(\\Delta h\\):\n\n\n\nError vs Step size\n\n\nThis sums up my attempt of problem08.",
    "crumbs": [
      "Solutions",
      "problem08"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem06/index.html",
    "href": "content/DynamicsSimulations/solutions/problem06/index.html",
    "title": "problem06",
    "section": "",
    "text": "6. Spring and mass (2D). One end of of a negligible-mass spring (k, L0) is pinned to the origin, the other to a mass (m). There is gravity (g). Initial Conditions (ICs): The initial position is \\(\\vec{r}\\_0 = x\\_0\\hat{i} + y\\_0\\hat{j}\\), and the initial velocity is \\(\\vec{v}\\_0 = v\\_{x0}\\hat{i} + v\\_{y0}\\hat{j}\\). Motion starts at \\(t = 0\\) and ends at tend.\n(a) Find the Equations of Motion (EoM);  \n(b) Assume all parameters and IC’s above are given.  \n    i. Plot the trajectory of the mass.  \n    ii. Animate the trajectory of the mass.  \n(c) How many ways can you think of checking the numerical solution, find as manyas you can, and do the check. The list is started here:\n    i. k = 0, all else arbitrary: The motion is parabolic flight (including fallingstraight down as a special case) [Why? The system is then just ballisticsfrom freshman physics];\n    ii. x0 = 0, vx0 = 0, all else arbitrary: The motion stays on the y axis [Why?There is no force in the x direction if the mass is on the y axis. Becausethe initial velocity has no x component, the mass never leaves the y axis;\n    iii. g = 0,*v0 =*0, all else is arbitrary: The motion stays on a radial line. And,if the motion does not cross the origin, the motion is that of a harmonicoscillator (sinusoidal oscillations, check by plotting, say x vt t. [Why? Writethe EoM and EoMs in polar coordinates⇒ mr¨ = −k(r − L0) ⇒ the harmonic oscillator equation, mr¨∗ =−kr∗, where r∗ ≡ r − L0.\n    iv. L0 = 0, all else is arbitrary: ? . [Why? ? .] Hint, this onespecial case is problem 10, below.v. etc.vi. etc.vii. . . .  \n\nSince I already did all of this pretty much in problem 1. I will instead write a simple lorentz system and animate it here.\nIn file ./lorentz_system.jl:\nusing DifferentialEquations\nusing GLMakie\n\n# ----------------------------\n# Define the Lorenz System\n# ----------------------------\n# The Lorenz system is given by:\n#   dx/dt = σ (y - x)\n#   dy/dt = x (ρ - z) - y\n#   dz/dt = x y - β z\nfunction lorenz!(du, u, p, t)\n    σ, ρ, β = p\n    du[1] = σ * (u[2] - u[1])\n    du[2] = u[1] * (ρ - u[3]) - u[2]\n    du[3] = u[1] * u[2] - β * u[3]\nend\n\n# ----------------------------\n# Set Parameters, Initial Conditions, and Solve the ODE\n# ----------------------------\n# Typical parameter values for the Lorenz system:\np = (10.0, 28.0, 8/3)\nu0 = [1.0, 0.0, 0.0]  # initial condition\ntspan = (0.0, 40.0)   # simulation time\n\n# Set up the ODE problem and solve it.\nprob = ODEProblem(lorenz!, u0, tspan, p)\nsol = solve(prob, Tsit5(); saveat=0.01)\n\n# ----------------------------\n# Create the Animation with Makie\n# ----------------------------\n# Create a new scene with a 3D camera.\nscene = Scene(resolution = (800, 600), camera = campixel!)\n\n# Plot the full trajectory as a blue line.\nlines!(scene, sol[1, :], sol[2, :], sol[3, :],\n       color = :blue, linewidth = 1)\n\n# Initialize a red marker for the moving point.\n# We start with the first position.\npoint = scatter!(scene, [sol[1,1]], [sol[2,1]], [sol[3,1]],\n                 markersize = 15, color = :red)\n\n# Record the animation. Here, each frame updates the position of the point.\nrecord(scene, \"lorenz_animation.gif\", length(sol.t)) do i\n    # Update the marker position to the i-th solution point.\n    point[1].attributes[:positions][] = Point3f0(sol[1,i], sol[2,i], sol[3,i])\n    # Optionally, you can adjust the frame rate by pausing briefly:\n    sleep(0.001)\nend\n\nprintln(\"Animation saved as lorenz_animation.gif\")\nThis produces the following animation:\n\n\n\n../../media/problem06/lorentz_attractor.gif\n\n\nThe code given on Makie.jl library website:\nusing GLMakie\n\nBase.@kwdef mutable struct Lorenz\n    dt::Float64 = 0.01\n    σ::Float64 = 10\n    ρ::Float64 = 28\n    β::Float64 = 8/3\n    x::Float64 = 1\n    y::Float64 = 1\n    z::Float64 = 1\nend\n\nfunction step!(l::Lorenz)\n    dx = l.σ * (l.y - l.x)\n    dy = l.x * (l.ρ - l.z) - l.y\n    dz = l.x * l.y - l.β * l.z\n    l.x += l.dt * dx\n    l.y += l.dt * dy\n    l.z += l.dt * dz\n    Point3f(l.x, l.y, l.z)\nend\n\nattractor = Lorenz()\n\npoints = Observable(Point3f[])\ncolors = Observable(Int[])\n\nset_theme!(theme_light())\n\nfig, ax, l = lines(points, color = colors,\n    colormap = :inferno, transparency = true,\n    axis = (; type = Axis3, protrusions = (0, 0, 0, 0),\n              viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))\n\nrecord(fig, \"lorenz_makie.gif\", 1:120) do frame\n    for i in 1:50\n        push!(points[], step!(attractor))\n        push!(colors[], frame)\n    end\n    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120)\n    notify(points)\n    notify(colors)\n    l.colorrange = (0, frame)\nend\nThis produces:\n\n\n\n../../media/problem06/lorenz_makie.gif\n\n\nIs there a way to think about verifying lorentz system solutions? I haven’t thought through this yet.",
    "crumbs": [
      "Solutions",
      "problem06"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem04/index.html",
    "href": "content/DynamicsSimulations/solutions/problem04/index.html",
    "title": "problem04",
    "section": "",
    "text": "4. Cross product: geometry vs components.\na) The geometric definition of crossproduct is this $\\vec{a} \\times \\vec{b}$ is a vector $\\vec{c}$ with magnitude $\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin\\theta_{ab}$ that is orthmorogonal to $\\vec{a}$ and $vec{b}$ in the direction given by the right hand rule. Use this definition to findan alternative geometric definition involving projection (namely: project $\\vec{b}$ onto theplane that is orthogonal to $\\vec{a}$; then stretch it by $\\vec{|a|}$; then rotate it $\\pi/2$ around the $\\vec{a}$ axis). Use that definition to show the distributive rule $\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$.  \nb) Then use the distributive rule to find the component formula for cross product,namely that $\\vec{a} \\times \\vec{b} = (a_2 b_3 − a_3 b_2)\\hat{e}_1 + (a_3 b_1 − a_1 b_3) \\hat{e}_2 + (a_1 b_2 − a_2 b_1)\\hat{e}_3$.  \nNote that, this distributive law implies that, for given \\(va \\times \\vec{v}\\) is a linear operator.That is \\(va \\times \\vec{v}\\) is a linear function fo \\(\\vec{v}\\). Later in the course we will use this to replacethe cross product with a tensor product. Hint: You can read about this in, say, theRuina/Pratap book (box 1.7).\n\nThe cross product \\(\\vec{a} \\times \\vec{b}\\) is defined geometrically as a vector \\(\\vec{c}\\) with magnitude \\(\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin \\theta_{ab}\\), direction orthogonal to both \\(\\vec{a}\\) and \\(\\vec{b}\\), and orientation following the right-hand rule. We can reformulate this using projection. First, project \\(\\vec{b}\\) onto the plane orthogonal to \\(\\vec{a}\\) using the formula \\(\\vec{b}_{\\perp} = \\vec{b} - (\\vec{b}\\cdot\\hat{a})\\hat{a}\\), where \\(\\hat{a}\\) is the unit vector in direction of \\(\\vec{a}\\). The magnitude of this projection is \\(\\|\\vec{b}\\_{\\perp}\\| = \\|\\vec{b}\\|\\sin \\theta\\)\nThen stretch this vector by \\(\\|\\vec{a}\\|\\), giving \\(\\|\\vec{a}\\|\\vec{b}\\_{\\perp}\\) with magnitude \\(\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin \\theta\\). Finally, rotate this vector by \\(\\pi/2\\) around the \\(\\vec{a}\\) axis, which preserves magnitude while making the result orthogonal to both \\(\\vec{a}\\) and \\(\\vec{b}\\_{\\perp}\\) in the right-hand rule direction. This construction yields a vector identical to the original definition.\nTo prove distributivity, \\(\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}\\), we use this new geometric definition. When we project \\((\\vec{b} + \\vec{c})\\) onto the plane perpendicular to \\(\\vec{a}\\), linearity of projection gives us \\((\\vec{b} + \\vec{c})\\_{\\perp} = \\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}\\). Stretching by \\(\\|\\vec{a}\\|\\) is also linear: \\(\\|\\vec{a}\\|(\\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}) = \\|\\vec{a}\\|\\vec{b}\\_{\\perp} + \\|\\vec{a}\\|\\vec{c}\\_{\\perp}\\). Since rotation by \\(\\pi/2\\) is linear, \\(R\\_{\\pi/2}(\\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}) = R\\_{\\pi/2}\\vec{b}\\_{\\perp} + R\\_{\\pi/2}\\vec{c}\\_{\\perp}\\), proving the distributive property.\nTo derive the component formula, we use distributivity: \\(\\vec{a} \\times \\vec{b} = (a\\_1\\hat{e}\\_1 + a\\_2\\hat{e}\\_2 + a\\_3\\hat{e}\\_3) \\times (b\\_1\\hat{e}\\_1 + b\\_2\\hat{e}\\_2 + b\\_3\\hat{e}\\_3) = \\sum\\_{i,j} a\\_ib\\_j(\\hat{e}\\_i \\times \\hat{e}\\_j)\\). Using the standard basis cross products (\\(\\hat{e}\\_1 \\times \\hat{e}\\_2 = \\hat{e}\\_3\\), \\(\\hat{e}\\_2 \\times \\hat{e}\\_3 = \\hat{e}\\_1\\), \\(\\hat{e}\\_3 \\times \\hat{e}\\_1 = \\hat{e}\\_2\\), \\(\\hat{e}\\_i \\times \\hat{e}\\_i = 0\\), \\(\\hat{e}\\_j \\times \\hat{e}\\_i = -(\\hat{e}\\_i \\times \\hat{e}\\_j)\\)), we expand and group terms to get the final component formula: \\(\\vec{a} \\times \\vec{b} = (a\\_2b\\_3 - a\\_3b\\_2)\\hat{e}\\_1 + (a\\_3b\\_1 - a\\_1b\\_3)\\hat{e}\\_2 + (a\\_1b\\_2 - a\\_2b\\_1)\\hat{e}\\_3\\).",
    "crumbs": [
      "Solutions",
      "problem04"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem02/index.html",
    "href": "content/DynamicsSimulations/solutions/problem02/index.html",
    "title": "problem02",
    "section": "",
    "text": "2. 3D. Get good at vectors. Assume that the positions relative to an origin of four random points, which are randomly located in space are given as \\(\\vec{\\mathbf{r}}_A\\), \\(\\vec{\\mathbf{r}}_B\\), \\(\\vec{\\mathbf{r}}_C\\) and \\(\\vec{\\mathbf{r}}_D\\). Assume force \\(\\vec{\\mathbf{F}}\\) is given. For each problem below write a single vector formula (one for each problem) that answers the question.\na) The points A and B define an infinite line. So do the points C and D. Find the distance between these two lines. ‘The’ distance means ‘the minimum distance’, that is the length of the shortest line segment connecting the two lines. Either write a formula (or sequence of formulas), or write computer code that gives the answer, or both.  \nb) Same problem as above, but also find the end points of the shortest line segment.  \nc) Find the volume of the tetrahedron ABCD (you should reason-out and not quote any formulas for the volume of a tetrahedron, that is, see if you can derive the formula: ’volume = one third base times height’).  \nd) Assume points A, B and C are fixed to a structure. All three are connected, by massless rods, to a ball and socket at each end, to point D. At point D the force  F is applied. Find the tension in bar AD. Find a formula for the answer, or write computer code to find the answer, or both. The goal is to find a formula for the tension in terms of the positions and the force vector.\n\n\nWrite formula or code for the length of the shortest line segment\nThe lines can be represented as:\n\\[l_1: \\vec{p}_1(\\lambda_1) = \\quad \\vec{\\mathbf{r}}_A + \\lambda_1 (\\vec{\\mathbf{r}}_B-\\vec{\\mathbf{r}}_A)\\]\n\\[l_2: \\vec{p}_2(\\lambda_2) = \\quad \\vec{\\mathbf{r}}_C + \\lambda_2 (\\vec{\\mathbf{r}}_D-\\vec{\\mathbf{r}}_C)\\]\nHence, for two points on either lines, \\(p_1\\), \\(p_2\\), the distance is:\n\\[D(\\lambda_1, \\lambda_2) = \\quad \\left|\\left| \\mathbf{\\vec{p}}_2 - \\mathbf{\\vec{p}}_1 \\right|\\right|_n\\]\nWhich can be framed as an optimisation problem, minimum length, \\(\\hat{s}\\):\n\\[\\hat{s} = \\quad \\min_{\\lambda_1, \\lambda_2} || \\left( \\vec{\\mathbf{r}}_A + \\lambda_1 (\\vec{\\mathbf{r}}_B-\\vec{\\mathbf{r}}_A) - (\\vec{\\mathbf{r}}_C + \\lambda_2 (\\vec{\\mathbf{r}}_D-\\vec{\\mathbf{r}}_C)) \\right) ||_n\\]\nor,\n\\[\\hat{s} \\leftarrow D\\left\\{ \\nabla D(\\lambda_1, \\lambda_2) = 0 \\right\\}\\]\nThe code corresponding to this in file ./MinimumDistanceBetweenTwoLines/src/MinimumDistanceBetweenTwoLines.jl is:\nmodule MinimumDistanceBetweenTwoLines\n\nimport Symbolics\nimport LinearAlgebra\n\n# problem setup\nconst N = 3\nSymbolics.@variables r⃗ₛ[1:N] r⃗ₜ[1:N] r⃗ᵤ[1:N] r⃗ᵥ[1:N]\nSymbolics.@variables λ₁ λ₂\n\np⃗₁ = r⃗ₛ + λ₁ * (r⃗ₜ - r⃗ₛ)\np⃗₂ = r⃗ᵤ + λ₂ * (r⃗ᵥ - r⃗ᵤ)\ns⃗ = p⃗₂ - p⃗₁\nD² = LinearAlgebra.dot(s⃗, s⃗)\nD² = Symbolics.scalarize(D²)\n∇D² = Symbolics.gradient(D², [λ₁, λ₂])\neq = ∇D² .~ 0\n\nlambdas_symbolic = Dict([λ₁, λ₂] .=&gt; Symbolics.symbolic_linear_solve(eq, [λ₁, λ₂]))\np̂₁_symbolic, p̂₂_symbolic = Symbolics.substitute.([p⃗₁, p⃗₂], Ref(lambdas_symbolic))\nŝ_symbolic = Symbolics.substitute.(D², Ref(lambdas_symbolic))\n\n#...\nNote that in the code, we are optimising for distance squared, and the \\(s\\) symbols in the code represent the distance squared.\nIn the same file, we take specific values:\n#...\n\n# evaluation\nsubs = Dict(\n    r⃗ₛ =&gt; [0.0, 0.0, 0.0],\n    r⃗ₜ =&gt; [1.0, 0.0, 0.0],\n    r⃗ᵤ =&gt; [0.0, 0.0, 1.0],\n    r⃗ᵥ =&gt; [0.0, 1.0, 2.0],\n    # λ₁ =&gt; 3,\n    # λ₂ =&gt; 4,\n)\n∇D²_eval = Symbolics.substitute.(∇D², Ref(subs))\n\neq_eval = Symbolics.substitute.(eq, Ref(subs))\n\nresult_eval = Dict(symbol =&gt; Symbolics.substitute(expresion, subs) for (symbol, expresion) in lambdas_symbolic)\nmerged_eval = merge(subs, result_eval)\n\nŝ_eval = Symbolics.substitute.(D², Ref(merged_eval))\np̂₁_eval, p̂₂_eval = Symbolics.substitute.([p⃗₁, p⃗₂], Ref(merged_eval))\n\nprintln(\"=== Substituted results: =====\")\nprintln(\"Λ̂  : \", result_eval)\nprintln(\"ŝ  = \", ŝ_eval)\nprintln(\"p̂₁ = \", p̂₁_eval)\nprintln(\"p̂₂ = \", p̂₂_eval)\n\nprintln(\"\\n=== Symbolic results: =====\")\nprintln(\"Λ̂  : \", lambdas_symbolic)\nprintln(\"ŝ  = \", Symbolics.scalarize(ŝ_symbolic))\nprintln(\"p̂₁ = \", Symbolics.scalarize(p̂₁_symbolic))\nprintln(\"p̂̂₂ = \", Symbolics.scalarize(p̂₂_symbolic))\n\nend # module MinimumDistanceBetweenTwoLines\nThis produces the following:\njulia&gt; include(\"src/MinimumDistanceBetweenTwoLines.jl\")\nWARNING: replacing module MinimumDistanceBetweenTwoLines.\n=== Substituted results: =====\nΛ̂  : Dict{Symbolics.Num, Float64}(λ₂ =&gt; -0.5, λ₁ =&gt; -0.0)\nŝ  = 0.5\np̂₁ = [0.0, 0.0, 0.0][Base.OneTo(3)]\np̂₂ = [0.0, -0.5, 0.5][Base.OneTo(3)]\n\n=== Symbolic results: =====\nΛ̂  : Dict{Symbolics.Num, SymbolicUtils.BasicSymbolic{Real}}(λ₂ =&gt; ((-(2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(⃗rₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-⃗rᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), λ₁ =&gt; ((-((-(2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)))\nŝ  = (r⃗ᵤ[1] - r⃗ₛ[1] + ((-r⃗ᵤ[1] + r⃗ᵥ[1])*(((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + (((((-(-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - ⃗rₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(r⃗ₛ[1] - r⃗ₜ[1])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)))^2 + (r⃗ᵤ[2] - r⃗ₛ[2] + (((((-(-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(r⃗ₛ[2] - r⃗ₜ[2])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[2] + r⃗ᵥ[2])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)))^2 + (r⃗ᵤ[3] - r⃗ₛ[3] + ((((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) - 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[3] + r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)))^2\np̂₁ = Symbolics.Num[r⃗ₛ[1] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(⃗rₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[1] + r⃗ₜ[1])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)), r⃗ₛ[2] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - ⃗rₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[2] + r⃗ₜ[2])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)), r⃗ₛ[3] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[3] + r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2))]\np̂̂₂ = Symbolics.Num[r⃗ᵤ[1] + ((-r⃗ᵤ[1] + r⃗ᵥ[1])*(((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-⃗rᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), r⃗ᵤ[2] + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[2] + r⃗ᵥ[2])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), r⃗ᵤ[3] + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2))]\nMain.MinimumDistanceBetweenTwoLines\n\n\nAlso find the end points of the shortest line segment\nThe formulation above can be reused, the optimal lambdas \\(\\hat{\\Lambda} = (\\lambda_1, \\lambda_2)\\), correspond to the closest points through the equation of the lines.\n\\[\\left(\\hat{\\lambda}_1, \\hat{\\lambda}_2\\right) = \\underset{\\lambda_1, \\lambda_2}{\\texttt{argmin}} \\left\\{ D(\\lambda_1, \\lambda_2) \\right\\}\\]\nA specific example’s numerical output was given in the previous section.\n\n\nFind the volume of the tetrahedron\nFor any 2d shape extended to a point, the volume is \\(\\frac{1}{3} \\text{Base-Area} \\times \\text{height}\\). Why? Take a slice, the planar dimensions reduce linearly to zero, so the area reduces quadratically. Integrate the function for the area as a function of the height from base to the tip.\nThis way, we can see that a tetrahedron is geometric one-sixth of a parallelapiped, therefore, volume \\(V(\\vec{\\mathbf{r}}_a, \\vec{\\mathbf{r}}_b, \\vec{\\mathbf{r}}_c, \\vec{\\mathbf{r}}_d)\\) is (assuming the vectors are in three dimensions for cross product to work):\n\\[V(\\vec{\\mathbf{r}}_a, \\vec{\\mathbf{r}}_b, \\vec{\\mathbf{r}}_c, \\vec{\\mathbf{r}}_d) = \\frac{1}{6} \\left|(\\vec{\\mathbf{r}}_c - \\vec{\\mathbf{r}}_b) \\times (\\vec{\\mathbf{r}}_c - \\vec{\\mathbf{r}}_a) \\cdot (\\vec{\\mathbf{r}}_d - \\vec{\\mathbf{r}}_d)\\right|\\]\n\n\nWrite formula or code for the tensions in the rods\n\\[\\vec{\\mathbf{F}} + T_{ad}\\hat{r}_{ad} + T_{bd}\\hat{r}_{bd} + T_{cd}\\hat{r}_{cd} = \\vec{\\mathbf{0}}\\]\nThere was an in-class mention about Cramer’s rule to solve this. There are three equations and three unknowns, but one could use Gaussian-elimination.\nThe other way to solve this using vector algebra is to dot the whole equation with a vector which is perpendicular to two of the three tension vectors. For example by \\(\\hat{r}_{ad}\\).",
    "crumbs": [
      "Solutions",
      "problem02"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/index.html",
    "href": "content/DynamicsSimulations/index.html",
    "title": "Dynamics",
    "section": "",
    "text": "Abstract Image\n\n\nThis page lists all of the homework solutions to a set of problems in Dynamics and Simulations. I have used the Julia Programming Language.\n\n\n\n\n\n\n\n\n\n\nproblem01\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem02\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem03\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem04\n\n\n\n\n\n\n\n\nFeb 4, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem05\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem06\n\n\n\n\n\n\n\n\nJan 24, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem07\n\n\n\n\n\n\n\n\nFeb 24, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem08\n\n\n\n\n\n\n\n\nFeb 25, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem09\n\n\n\n\n\n\n\n\nFeb 26, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem10\n\n\n\n\n\n\n\n\nMar 25, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem11\n\n\n\n\n\n\n\n\nApr 2, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem12\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem13\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem14\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem15\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem16\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem17\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem18\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem19\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\nproblem20\n\n\n\n\n\n\n\n\nApr 12, 2025\n\n\nVishal Paudel\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Content",
      "Dynamics"
    ]
  },
  {
    "objectID": "content/Blog/posts/welcome/index.html",
    "href": "content/Blog/posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts.",
    "crumbs": [
      "Posts",
      "Welcome To My Blog"
    ]
  },
  {
    "objectID": "content/Blog/index.html",
    "href": "content/Blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Profile\n\n\nThis blog is intended to be a place to share ideas and results that are too weird, incomplete, or off-topic to turn into an academic paper, but that I think may be important. Let me know what you think! Contact links on the bottom.\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\n\n\n\n\n\nApr 21, 2025\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\n\nApr 18, 2025\n\n\nTristan O’Malley\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Content",
      "Blog"
    ]
  },
  {
    "objectID": "content/Blog/posts/post-with-code/index.html",
    "href": "content/Blog/posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.",
    "crumbs": [
      "Posts",
      "Post With Code"
    ]
  },
  {
    "objectID": "content/Bookmarks/index.html",
    "href": "content/Bookmarks/index.html",
    "title": "Bookmarks",
    "section": "",
    "text": "Once I start earning I want to buy these subscriptions:\n\nMathAcademy\nMasterClass\nRendering Black Holes\n\nin the about section of this part of the site add later:\nscrapbook, I was thinking of scrapbook being a legitimate title and analogy for this section of the site, just then, I searched for srapbook-dot-com and found on their homepage that there is something called as international scrapbook day, and [[coincidence]] the day today (Saturday, 03 May) is that day (scrapbook day is celebrated on first saturday of May).\n\nhistory\n- name: Bronson\n  status: todo\n  category: movie\n  info: a biopic based loosely on [[charles-bronson]] (prisoner) staring [[tom-hardy]].\n  count: +1\n- name: Andreas Kling\n  status: done\n  category: video\n  info: a browser tinkerer, browser professional, drug addict, back to oss and rocking\n  count: +1\n\n\nideas\n- ripgrep for websites\n  info: recursively opening links and searching text in website, potentially regex\n  count: +1+1\n- visual feedback for scroll location\n  info: render scrollbars useless with alternative spatially static visual\n  count: +1+1",
    "crumbs": [
      "Content",
      "Bookmarks"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem01/index.html",
    "href": "content/DynamicsSimulations/solutions/problem01/index.html",
    "title": "problem01",
    "section": "",
    "text": "1. Set up (define system, draw FBD, write ODEs) a particle problem. Just one particle. 2D or 3D, your choice. Use a force, or forces that you like (gravity, spring, air friction). Any example of interest. Find a numerical solution. Graph it. Animate it. Try to make an interesting observation.\n\n\nSystem Description and Free Body Diagram\nI think I have chosen a just hard enough interesting problem. A spring pendulum consists of a mass \\(m\\) attached to a spring of natural length \\(l_0\\) and spring constant \\(k\\).\nThe system experiences: - Spring force \\(\\vec{F_s} = k(\\|{\\vec{r}\\|}-l_0)(-\\hat{r})\\) - Gravitational force \\(\\vec{F_g} = mg(-\\hat{j})\\) - Damping force \\(\\vec{F_d} = cv(-\\hat{v})\\)\n\n\n\nFreebody-diagram\n\n\n\n\nEquations of Motion\nIn Cartesian coordinates, the equations of motion are:\n\\[\\dot{\\vec{r}} = \\vec{v}\\] \\[\\dot{\\vec{v}} = -k(\\|\\vec{r}\\|-l_0) \\hat{r} - c \\vec{v} - mg\\hat{j}\\]\nThe corresponding code for the ODE in file ./SpringPendulum/src/Physics.jl:\nmodule Physics\n\nusing ..Parameters\nusing LinearAlgebra\nusing UnPack\n\nexport spring_pendulum!\n\nfunction spring_pendulum!(du, u, p::Parameters.Param, t)\n    @unpack mass, gravity, stiffness, restinglen, viscosity = p\n\n    r⃗ = u[1:2]\n    v⃗ = u[3:4]\n\n    ĵ = [0.0; 1.0]\n    gravity = mass * gravity * (-ĵ)\n    spring = stiffness * (norm(r⃗) - restinglen) * (-normalize(r⃗))\n    drag = -viscosity * v⃗\n\n    force = (spring + drag + gravity)\n\n    du[1:2] = v⃗\n    du[3:4] = force / mass\nend\n\nend\n\n\nNumerical Solution\nIn file ./SpringPendulum/src/SpringPendulum.jl\nmodule SpringPendulum\n\nusing DifferentialEquations\n\ninclude(\"Parameters.jl\")\ninclude(\"Physics.jl\")\ninclude(\"Visualization.jl\")\n\n# problem setup\nx₀, y₀ = (1, 0)\nr₀ = [x₀;y₀]\nv₀ = [1.0;0.0]\nu₀ = [r₀;v₀]\ntspan = (0.0,25.0)\np = Parameters.Param(m=1,g=1,c=0.0,k=1,l₀=0)\nprob = ODEProblem(Physics.spring_pendulum!, u₀, tspan, p)\n\n# solver\nΔt = 0.001\nsol = solve(prob, saveat=Δt, reltol=1e-6, abstol=1e-6)\n\n# visualize\n# ...\n\nend # module SpringPendulum\n\n\nPhase Space Trajectory\nPlot showing the system evolution in phase space. In file ./SpringPendulum/src/Visualization.jl:\n\n\n\nLeft: Trajectory plot. Right: Theta vs Time\n\n\nCode corresponding to this in file SpringPendulum/src/Visualization.jl:\nfunction plot_trajectory(sol; title=\"Spring Pendulum Trajectory\")\n    a = reduce(hcat, sol.u)'\n    x =  a[:, 1]\n    y = a[:, 2]\n    θ = atan.(a[:, 2], a[:, 1])\n\n    xlimits = (minimum(x)-1, maximum(x)+1)\n    ylimits = (minimum(y)-1, maximum(y)+1)\n\n    trajectory_plot = Figure()\n    trajectory = Axis(trajectory_plot[1, 1],\n        title=title,\n        xlabel=\"X position\",\n        ylabel=\"Y position\",\n        limits=(xlimits, ylimits),\n        aspect=1,\n    )\n    lines!(trajectory, x, y,\n        label=\"Trajectory\",\n    )\n    axislegend(position=:rb)\n\n    trajectory = Axis(trajectory_plot[1, 2],\n        title=\"Theta vs time\",\n        xlabel=\"Time\",\n        ylabel=\"Theta\",\n    )\n    lines!(trajectory, sol.t, θ)\n\n    return trajectory_plot\nend\n\n\nAnimation\nThe following shows the animation for the solution system. The code corresponding to this animation:\n\n\nTODO: add springs to visualise\n\n\n\nSpring Pendulum Motion\n\n\nThe code corresponding to this animation is in file ./SpringPendulum/src/Visualization.jl:\nfunction makie_animation(sol; filename=\"sol_animation.gif\", title=\"Animation\")\n    sol_matrix = reduce(hcat, sol.u)'\n    x =  sol_matrix[:, 1]\n    y = sol_matrix[:, 2]\n    θ = atan.(sol_matrix[:, 2], sol_matrix[:, 1])\n\n    # coarse boundaries, for continuous(interpolated) boundary see: https://docs.sciml.ai/DiffEqDocs/stable/examples/min_and_max/\n    xlimits = (minimum(x)-1, maximum(x)+1)\n    ylimits = (minimum(y)-1, maximum(y)+1)\n\n    time = Observable(0.0)\n\n    x = @lift(sol($time)[1])\n    y = @lift(sol($time)[2])\n\n    # Create observables for line coordinates\n    line_x = @lift([0, $x])\n    line_y = @lift([0, $y])\n\n    animation = Figure()\n    ax = Axis(animation[1, 1], title = @lift(\"t = $(round($time, digits = 1))\"), limits=(xlimits, ylimits), aspect=1)\n\n    scatter!(ax, x, y, color=:red, markersize = 15)\n    lines!(ax, line_x, line_y, color=:black)\n\n    framerate = 30\n    timestamps = range(0, last(sol.t), step=1/framerate)\n\n    record(animation, filename, timestamps;\n            framerate = framerate) do t\n        time[] = t\n    end\n\n    return animation\nend\n\n\nObservations\n\nEnergy exchange between potential and kinetic forms\nDamped oscillations due to viscous friction\nFor some parameters there is weird behaviour at very small scales. This is probably an artifact of the solver and floating point truncations. I was unable to reproduce this, but I had shown this to Professor Andy and Ganesh Bhaiya.\nIncreasing c by a little has a drastic effect\nThe problem was fun to simulate\nJulia was fun to code in: Libraries were ergonomic to use, DifferentialEquations.jl, and Makie.jl\nI noticed only much later that all of the trajectories for when resting length is zero are elipses.",
    "crumbs": [
      "Solutions",
      "problem01"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem03/index.html",
    "href": "content/DynamicsSimulations/solutions/problem03/index.html",
    "title": "problem03",
    "section": "",
    "text": "3. More ODE & animation practice. Take a simple set of ODEs. Use a set you like,e.g., harmonic oscillator, non-linear pendulum, the Lorentz system (look it up on the internet). Solve this set numerically 3 ways (see below), and understand the accuracy. The goal is that, by the time you hand in the homework, you can write and debug the assignment on your own without looking up anything (outside of trivial syntax things). And you always have a good sense of the accuracy of your solution.\na. Method 1: as simply as possible, without ODE45, and without calling functions or anything like that. A single function or script file with no function calls (ok, plotting calls are ok). Just write a simple loop that implements Euler’s method with your ODE.  \nb. With your own Euler solver function. Your main program should call your Euler solver. Your Euler solver should call a RHS (Right Hand Side) function.  \nc. With ODE45.  \nd. Using (b), solve the equations many times with progressively smaller step size, down to the smallest size you have patience for, and up to the largest size that isn’t crazy. As sensibly as possible, compare the results and use that comparison to estimate the accuracy of each solution. You should be able to find a method to estimate the accuracy of a numerical solution even without knowing the exact solution.  \ne. Using ODE45, solve the equations with various accuracies (use ’reltol’ and ’abstol’, note MATLAB satisfies one or the other, whichever is easiest. So, if you want an accurate solution you need to make both ’reltol’ and ’abstol’ small). Does Matlab do a good job of estimating its own accuracy? Use suitable plots to make your point.",
    "crumbs": [
      "Solutions",
      "problem03"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem03/index.html#tailmatch-characterisation",
    "href": "content/DynamicsSimulations/solutions/problem03/index.html#tailmatch-characterisation",
    "title": "problem03",
    "section": "TailMatch Characterisation",
    "text": "TailMatch Characterisation\nThe ‘tailmatch’ is quite easily implemented in code, in file ./ODESolvers/src/Benchmarks.jl:\ntail_match(sol1::ProblemTypes.Solution, sol2::ProblemTypes.Solution)::ProblemTypes.AbsError = norm(sol2[end] - sol1[end])\nSince my current implementation saves updated state at each step, benchmarking for progressively reducing step sizes takes a lot of memory on top of time. I will update the euler solver to not save at each time step, benchmark at smaller step sizes later. For now, for the step size, I have gone till 1e-6 and the plot for the benchmark, with tail_match is as follows:\n\n\n\nStep sizes vs AbsError\n\n\n\n\nTODO: fix memory issue and go till 1e-15\nI have done some deep (very small) comparision of Midpoint and RK4 in ../problem09",
    "crumbs": [
      "Solutions",
      "problem03"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem03/index.html#slither-charaterisation",
    "href": "content/DynamicsSimulations/solutions/problem03/index.html#slither-charaterisation",
    "title": "problem03",
    "section": "Slither Charaterisation",
    "text": "Slither Charaterisation\nTo do this, we create some histories with different step sizes. I have skipped this for now.\n\n\nTODO: implement this",
    "crumbs": [
      "Solutions",
      "problem03"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem05/index.html",
    "href": "content/DynamicsSimulations/solutions/problem05/index.html",
    "title": "problem05",
    "section": "",
    "text": "5. Read up.\na. Read all of the course Teams posts so far, trying out all possible links of interest.  \nb. Make sure you thoroughly understand these sections of the Ruina/Pratap pdf book, available from Ruina’s www page:  \n   - Chapter 1 (read),\n   - Chapter 2 (skim, only study things you don’t know well already, make sure that within a few weeks you know all of this well. ),\n   - Chapter 3,\n   - Section 17.1,\n   - Appendix A.\nc. Write the following, if true, if not write that which is true:\n   &gt; “I have carefully done some of the reading assigned. That which I don’t understand or agree with, I have posted on the course Piazza site. I haven’t yet carefully read X [make appropriate substitutions for X]”.\n\nI have carefully done some of the reading assigned. That which I don’t understand or agree with, I have discussed in class. I haven’t yet carefully read Chapter 3, Section 17.1, Appendix A.",
    "crumbs": [
      "Solutions",
      "problem05"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem07/index.html",
    "href": "content/DynamicsSimulations/solutions/problem07/index.html",
    "title": "problem07",
    "section": "",
    "text": "7. Simple animation of a shape. Draw a picture of some object (a face, a house, whatever), and make it move around on the screen in a smooth and interesting way. No distortions. Just motions and rotations\n\nIn file ./simple_animation.jl:\nusing GLMakie\n\n# Create a figure\nfig = Figure(resolution = (800, 600))\nax = GLMakie.Axis(fig[1, 1], aspect = DataAspect())\nlimits!(ax, -5, 5, -5, 5)\n\n# Define the house vertices (centered at origin)\nhouse_vertices = [\n    # Main square\n    Point2f(-1, -1), Point2f(1, -1), Point2f(1, 1), Point2f(-1, 1), Point2f(-1, -1),\n    # Roof\n    Point2f(-1, 1), Point2f(0, 2), Point2f(1, 1)\n]\n\n# Create initial lines object\nhouse_lines = lines!(ax, house_vertices, color = :blue, linewidth = 2)\n\n# Animation parameters\nframes = 300\nangular_speed = 2π/frames  # Complete one rotation\ndrift_speed = 4/frames    # Total drift distance\n\n# Create the animation\nrecord(fig, \"rotating_house.gif\", 1:frames; framerate = 30) do frame\n    # Calculate rotation and drift\n    angle = angular_speed * frame\n    drift_x = drift_speed * frame - 2  # Start from left side\n    drift_y = sin(2π * frame/frames)   # Add some vertical oscillation\n    \n    # Apply transformation to each point\n    transformed_points = [\n        Point2f(\n            x * cos(angle) - y * sin(angle) + drift_x,  # Rotation + horizontal drift\n            x * sin(angle) + y * cos(angle) + drift_y   # Rotation + vertical oscillation\n        )\n        for (x, y) in [(p[1], p[2]) for p in house_vertices]\n    ]\n    \n    # Update the lines object\n    house_lines[1] = transformed_points\nend\nProduces this animation:\n\n\n\nFloating house in space",
    "crumbs": [
      "Solutions",
      "problem07"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem09/index.html",
    "href": "content/DynamicsSimulations/solutions/problem09/index.html",
    "title": "problem09",
    "section": "",
    "text": "9. Canon ball. A cannon ball m is launched at angle θ and speed v0. It is acted on by gravity g and a viscous drag with magnitude \\(\\|c\n\\vec{v}\\|\\).\n(a) Find position vs time analytically.  \n(b) Find a numerical solution using θ = π/4, $v_0 = 1$ m/s, g = 1 m/s 2 , m = 1 kg, c = 1 kg/ s.  \n(c) Compare the numeric and analytic solutions. At t = 2 how big is the error? How does the error depend on specified tolerances or step sizes?  \n(d) Use larger and larger values of v0 and for each trajectory choose a time interval so the canon at least gets back to the ground. Plot the trajectories (using equal scale for the x and y axis. Plot all curves on one plot. As v → ∞ what is the eventual shape? [Hint: the answer is simple and interesting.]  \n(e) For any given v0 there is a best launch angle θ ∗ for maximizing the range. As v0 → ∞ to what angle does θ ∗ tend? Justify your answer as best you can with careful numerics, analytical work, or both.  \n\n\n\n../../media/problem09/problem09.png\n\n\n\n\nFind position vs time analytically.\nThe corresponding code for this in file ./Ballistics/src/Ballistics.jl:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    u = zeros((4,))\n    u[1] = vx0 * (-c/m) * (exp((-c/m)*(t-t0)) - 1)\n    u[2] = ((vy0+(m*g/c))*(-c/m)*(exp((-c/m)*(t-t0)) - 1)) + ((-m*g/c)*(t-t0))\n    u[3] = (vx0) * (exp((-c/m)*(t-t0)))\n    u[4] = ((vy0) + (m*g/c)) * exp((-c/m)*(t-t0)) - (m*g/c)\n\n    return u\nend\nThis turned out to be wrong, it was an integral mistake (integration mistake). The corrected version in the same file:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    x = x0 + vx0 * ((-m / c) * exp((c / m) * (t0))) * (exp((-c / m) * t) - exp((-c / m) * t0))\n    y = y0 + ((vy0 + (m * g / c)) * (-m / c) * (exp((c / m) * t0)) * (exp((-c / m) * t) - exp((-c / m) * t0))) + ((-m * g / c) * (t - t0))\n    vx = (vx0) * (exp((-c / m) * (t - t0)))\n    vy = ((vy0) + (m * g / c)) * exp((-c / m) * (t - t0)) - (m * g / c)\n\n    u = zeros((4,))\n    u[1] = x\n    u[2] = y\n    u[3] = vx\n    u[4] = vy\n\n    return u\nend\n\n\nTODO: Could I have created this analytical solution symbolically?\n\n\nFind a numerical solution using given parameters\nThe corresponding code for this in file ./Ballistics/src/Ballistics.jl:\nusing DifferentialEquations\n#...\n# problem setup\nx0, y0 = 0.0, 0.0\nr0 = [x0; y0]\nspeed0 = 1\nlaunchangle = pi / 4\nvx0, vy0 = speed0 * [cos(launchangle); sin(launchangle)]\nv0 = [vx0; vy0]\nu0 = [r0; v0]\n\nt0 = 0.0\ntend = 1.0\ntspan = (t0, tend)\np = Parameters.Param(m=1, g=1, c=1)\nprob = ODEProblem(Physics.ballistic!, u0, tspan, p)\n#...\nsol_numeric = solve(prob)\n#...\nVisualization.plot_trajectory(sol_numeric.u)\nThis numerical solution gives the following trajectory:\n\n\n\n../../media/problem09/numerical_trajectory.png\n\n\n\n\nCompare the numeric and analytics solutions? Plot time vs error. Plot step size and tolerances vs error.\nFor various initial conditions, the numeric and analytical solutions on the same graph, I was shifting the analytic in x direction by 0.1 unit to be able view both, otherwise they were overlapping with the default tolerances, but then I ended up using a non-dynamic step size explicit solver:\nIn file ./Ballistics/src/Benchmarks.jl:\nmodule Benchmarks\n\nusing DifferentialEquations\nusing LinearAlgebra\n\n# Abs error for various step sizes\nfunction abs_error_vs_step_sizes(prob, analytical_solve)\n    # step_sizes = 10.0 .^ range(-1, -15, step=-1)\n    step_sizes = 10.0 .^ range(-1, -5, step=-1)\n    abs_errors_midpoint = Vector{Union{Missing, Float64}}(missing, length(step_sizes))\n    abs_errors_rk4 = Vector{Union{Missing, Float64}}(missing, length(step_sizes))\n\n    for (i,Δh) in enumerate(step_sizes)\n        sol_numeric_midpoint = solve(prob, Midpoint(), dt=Δh, adaptive=false, save_everystep=false)[end]\n        sol_numeric_rk4 = solve(prob, RK4(), dt=Δh, adaptive=false, save_everystep=false)[end]\n        tend = prob.tspan[2]\n        sol_analytic = analytical_solve(tend)\n\n        separation_midpoint = sol_numeric_midpoint - sol_analytic\n        separation_rk4 = sol_numeric_rk4 - sol_analytic\n        error_midpoint = norm(separation_midpoint)\n        error_rk4 = norm(separation_rk4)\n    \n        abs_errors_midpoint[i] = error_midpoint\n        abs_errors_rk4[i] = error_rk4\n    end\n\n    log_errors_midpoint = log10.(abs_errors_midpoint)\n    log_errors_rk4 = log10.(abs_errors_rk4)\n    log_errors_dict = Dict(\"midpoint\"=&gt;log_errors_midpoint, \"rk4\"=&gt; log_errors_rk4)\n    log_steps = log10.(step_sizes)\n\n    return log_steps, log_errors_dict\nend\n\n# Abs error for all times\nfunction error_vs_time(prob, analytical_solve)\n    N = 5\n    step_sizes = 10.0 .^ range(-1, -N, step=-1)\n    time_histories = Vector{Union{Missing, Vector{Float64}}}(missing, length(step_sizes))\n    error_histories = Vector{Union{Missing, Vector{Float64}}}(missing, length(step_sizes))\n    for (i,Δh) in enumerate(step_sizes)\n        sol = solve(prob, Midpoint(), dt=Δh, adaptive=false, save_everystep=true)\n\n        timestamps = sol.t\n        sol_numeric_midpoint = sol.u\n        sol_analytic = analytical_solve.(timestamps)\n\n        separations = sol_numeric_midpoint .- sol_analytic\n        manhatten_errors = norm.(separations, Ref(1))\n        error_histories[i] = log10.(manhatten_errors)\n        time_histories[i] = timestamps\n    end\n    return time_histories, error_histories\nend\n\n\nend # module Benchmarks\n\n\n\n../../media/problem09/numeric_and_analytical_trajectories.png\n\n\nNow, I will plot the steps sizes vs error (euclidean norm of state vector at tend):\n\n\n\n../../media/problem09/steps_vs_error.png\n\n\nFor a better method, like RK4, on the same graph:\n\n\n\n../../media/problem09/steps_vs_error_two_methods_compare.png\n\n\nNow, for time vs error compilation:\n\n\n\n../../media/problem09/time_vs_running_error.png\n\n\nNow, I will change the relative tolerance and absolute tolerance. In file ./Ballistics/src/Benchmarks.jl:\nfunction tolerances_vs_error(prob, analytical_solve)\n    N = 15\n    error_matrix = Matrix{Float64}(undef, N, N)\n    num_granularity = N+7\n    abstols = 10.0 .^ range(7, -N, length=num_granularity)\n    reltols = 10.0 .^ range(7, -N, length=num_granularity)\n\n    num_samples = length(abstols)*length(reltols)\n\n    xs = Vector{Float64}(undef, num_samples)\n    ys = Vector{Float64}(undef, num_samples)\n    zs = Vector{Float64}(undef, num_samples)\n\n    for (i, abstol) in enumerate(abstols)\n        for (j, reltol) in enumerate(reltols)\n            sol_numeric = solve(prob, Midpoint(), adaptive=true, save_everystep=false, abstol=abstol, reltol=reltol)[end]\n            sol_analytic = analytical_solve(prob.tspan[2])\n\n            separation = sol_numeric - sol_analytic\n            error = norm(separation)\n            xs[i+num_granularity*(j-1)] = abstol\n            ys[i+num_granularity*(j-1)] = reltol\n            zs[i+num_granularity*(j-1)] = error\n        end\n    end\n    xs,ys,zs\nend\nJust by mistake I ran this for large (&gt;1.0) tolerances. Below is the plot:\n\n\n\n../../media/problem09/large_tolerances.png\n\n\nSimilarly for tiny (&lt;&lt;1.0) tolerances the plot:\n\n\n\n../../media/problem09/small_tolerances.png\n\n\nBoth scales on the same graph:\n\n\n\n../../media/problem09/tolerances_vs_error_combined.png\n\n\nSimply put, it seems reducing both abstol and reltol generally reduces error from the analytic solution very quickly. What is the meaning of both is not yet entirely clear.\n\n\nUse larger and larger values of v0, plot all of their trajectory till ball hits ground. What happens to the eventual shape as v -&gt; ∞ ?\nThe code for this in file ./Ballistics/src/Ballistics.jl:\n# ...\n\nfunction solve_till_empty(prob)\n    conditionatbeggining(u, t, integrator) = t &gt; 0\n    removetstop!(integrator) = add_tstop!(integrator, ∞)\n    removetstopwhenbeginning = DiscreteCallback(conditionatbeggining,removetstop!)\n\n    condition(u, t, integrator) = u[2] &lt; 0\n    affect!(integrator) = terminate!(integrator)\n    stopwhenonground = DiscreteCallback(condition, affect!)\n\n    cb = CallbackSet(removetstopwhenbeginning, stopwhenonground)\n    sol = solve(prob, RK4(), callback = cb, tstops = [0.1,])\n\n    sol\nend\n\nfunction problem_setup(launchangle, speed0, c)\n    x0, y0 = 0.0, 0.0\n    r0 = [x0; y0]\n    vx0, vy0 = speed0 * [cos(launchangle); sin(launchangle)]\n    v0 = [vx0; vy0]\n    u0 = [r0; v0]\n\n    t0 = 0.0\n    tend = 1.0\n    tspan = (t0, tend)\n    p = Parameters.Param(m = 1, g = 1, c = c)\n    prob = ODEProblem(Physics.ballistic!, u0, tspan, p)\n    return prob\nend\n\nspeeds = range(0, 100)\nproblems = problem_setup.(Ref(pi/4), speeds, Ref(1))\nsols = solve_till_empty.(problems)\nVisualization.plot_all_trajectories(sols)\n\n# ...\nThe plot corresponding to this:\n\n\n\nIncreasing intial velocities\n\n\n\n\nPlot speed verses best launch angle, numerically or analyticaly or both\nI expect 45 degrees to still be consistantly good for launch even with drag.\nDoing this numerically, in file ./Ballistics/src/Benchmarks.jl:\n# ...\n\nfunction best_angle_for_speed(speed0, c)\n    launchangles = pi/4 .* ((range(-1.0, 1.0, 300)) .^ 3.0 .+ 1.0)\n\n    max_range = 0\n    argmax_theta = 0\n    for launchangle in launchangles\n        # problem setup\n        prob = problem_setup(launchangle, speed0, c)\n\n        sol = solve_till_empty(prob)\n        cur_range = sol.u[end][1]\n        if cur_range &gt; max_range\n            max_range = cur_range\n            argmax_theta = launchangle\n        end\n    end\n    argmax_theta\nend\n\nspeeds = 10.0 .^ range(0.0, 3.1, 100)\nbestangles = []\nfor speed0 in speeds\n    bestangle = best_angle_for_speed(speed0, 1)\n    push!(bestangles, bestangle)\nend\nVisualization.plot_best_angle_for_speeds(speeds, bestangles)\n\n# ...\nThe weird choice for launchangles is for concentrating numeric choices for launchangles near \\(\\pi \\over 4\\). This produces:\n\n\n\n../../media/problem09/speed_vs_bestangle_c_1.png\n\n\n\n\n\n../../media/problem09/speed_vs_bestangle_c_10.png\n\n\nIt seems that my intuition was way off. It seems the best angle quickly becomes closer to zero as the initial velocity increases.\nLet us plot the relation of drag with the best angle for a high velocity (say v = 1200), in file ./Ballistics/src/Ballistics.jl:\nspeed0 = 1200.0\nbestangles = []\ndrags = 2.0 .^ range(1.0, 5.0)\nfor c in drags\n    bestangle = best_angle_for_speed(speed0, c)\n    push!(bestangles, bestangle)\nend\nVisualization.plot_best_angle_vs_drag(drags, bestangles)\n\n\nTODO: There isn’t much change in the eventual best angle for large velocities as drag changes. It does not seem right, but the best angle in such case seems to be some constant close to zero. I will explore this more later. The plot generated by above code is:\n\n\n\n../../media/problem09/best_angle_vs_drag.png\n\n\nThis concludes my attempt of problem09.",
    "crumbs": [
      "Solutions",
      "problem09"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem11/index.html",
    "href": "content/DynamicsSimulations/solutions/problem11/index.html",
    "title": "problem11",
    "section": "",
    "text": "11. Central force. These two problems are both about central forces. In both cases the only force is central (directed on the particle towards the origin) and only depends on radius: \\(\\vec{\\mathbf{F}} = −F(r)\\mathbf{\\hat{e}_r}\\). The problems are independent, one does not follow from the other.\n\nFind a central force law \\(F(r)\\) so that, comparing circular orbits of varying radii, the speed v is independent of radius.\nBy numerical experiments, and trial and error, try to find a periodic motion that is neither circular nor a straight line, for some central force besides \\(F = −kr\\) or \\(F = \\frac{−GmM}{r2}\\) . a) not with a linear zero-rest length spring; b) not with inverse-square gravity; c) not circular motion; and d) not straight-line motion.\n\nIn your failed searches, before you find a periodic motion, do the motions always have regular patterns or are they sometimes chaotic looking (include some pretty pictures)?\nPuzzle: If you use a power law, what is the minimum number loops in one complete periodic orbit (a loop is, say, a relative maximum in the radius)? How does this depend on the exponent in the power law? You probably cannot make progress with this analytically, but you can figure it out with numerical experiments\n\n\n[Matlab hint: To do this properly you probably need to guess at a radial force law (most anything will work) and do numerical root finding (e.g., FSOLVE) to find initial conditions and the period of the orbit. Once you have your system you can define a function whose input is the initial conditions and the time of integration and whose output is the difference between the initial state and the final state. You can make this system ‘square’ by assuming that the particle is on the x axis in the initial state. You want to find that input which makes the output the zero vector. Pick a central force and search over initial conditions and durations. Do not use FSOLVE to search over force laws; do your orbit finding using a given force law]\n\n\n\n../../media/problem11/problem11.png\n\n\n\n\n(a) Find a central force law \\(F(r)\\) so that, comparing circular orbits of varying radii, the speed v is independent of radius.\nConsider the relationship between centripetal force and velocity for uniform circular motion, since velocity is constant we can write:\n\\[F(r) = \\frac{mv^2}{r}\\]\n\\[F(r) = k\\frac{m}{r}\\]\nQuickly drawing the trajectory for tangential initial conditions, in file ./CentralForce/src/CentralForce.jl:\nu0 = [1.0;0.0;0.0;1.0]\ntspan = (0.0,10.0)\nm = 1.0\nk = 1.0\np = Param(m, k)\node = Physics.speedindependentofradius!\node_prob = DifferentialEquations.ODEProblem(ode, u0, tspan, p)\nsol = DifferentialEquations.solve(ode_prob)\nThis produces:\n\n\n\n../../media/problem11/problem11_trajectory_central_force.png\n\n\nthe trajectory for non-tangential inital velocity:\n\n\nTODO: add graph for velocity vs radius\n\n\n(b) By numerical experiments, and trial and error, try to find a periodic motion that is neither circular nor a straight line, for some central force besides \\(F = −kr\\) or \\(F = \\frac{−GmM}{r2}\\) . a) not with a linear zero-rest length spring; b) not with inverse-square gravity; c) not circular motion; and d) not straight-line motion.\nFirst of all, I would like to note here that this was the most interesting and fun and investing problem so far in this problem set. I have spent almost 18 hours spread over 6 days on this problem.\nWe begin by formulating our problem:\nFor example, an interesting central force field is this:\nfunction dipolepowerlaw(r⃗, p)\n    p₁ = [1.0, 0.0]\n    p₂ = [0.0, +1.0]\n    p₃ = [-1.0, 0.0]\n    p₄ = [0.0, -1.0]\n    points = [p₁,p₂,p₃,p₄]\n    norms = norm.((r⃗ .- points))\n    k = -2\n    F = sum(inversepower.(norms, Ref{k}))\n    return F\nend\n#...\nfunction F(r⃗, p)\n    dipolepowerlaw(r⃗, p)\n    # speedindependentofradius(r⃗, p)\n    # inversepowerlaw(r⃗, p)\n    # hillinvalley(r⃗, p)\nend\n#...\nfunction centralforce!(du, u, p, t)\n    r⃗ = u[1:2]\n    v⃗ = u[3:4]\n    r̂ = normalize(r⃗)\n    F⃗ = F(r⃗, p) * (-r̂)\n    a⃗ = F⃗ / p.m\n    du[1:2] = v⃗\n    du[3:4] = a⃗\nend\nThe graph for this magnitude of this central force field looks like this:\n\n\n\nDipole power law\n\n\nFor any such function centralforce!(du, u::State, p::Parameters, tend:Time)::State, we want to find a \\(\\vec{u}_0\\) such that, for \\(\\vec{u}_t\\) = DifferentialEquations.solve(odeprob)[end]\n\\[\\vec{u}_t - \\vec{u}_0 = \\vec{0}\\]\nWhich is equivalent to finding a zero to the following function f, in file ./CentralForce/src/RootFinding.jl:\nf(z⃗₀, p) = begin\n    tol = 1e-12\n    u⃗₀ = z⃗₀[1:end-1]\n    tend = z⃗₀[end]\n    dynamics_prob = ProblemSetup.create_problem(ProblemSetup.ode!, u⃗₀, tend, p)\n    dynamics_sol = DifferentialEquations.solve(dynamics_prob; abstol=tol, reltol=tol, save_everystep=false)\n    u⃗ₜ = dynamics_sol.u[end]\n    Δu⃗ = u⃗ₜ - u⃗₀\n    phasecondition = u⃗₀[2] # crosses the x axis\n    # v⃗₀ = u⃗₀[3:4]\n    # limit = 0.1\n    # if LinearAlgebra.norm(v⃗₀) &lt; limit || tend &lt; 0.1\n    #     return zeros(5) .+ 1.0\n    # end\n    # Δu⃗\n    return [Δu⃗; phasecondition]\nend\nOne challenge I overcame after much thinking is regarding the phasecondition, the number of variables to solve for should equal the number of equations, earlier the input dimension was five: \\((x, y, vx, vy, tend)\\) while the output dimension was four (Δx, Δy, Δvx, Δvy).\nThe following is the question I asked in a julia help group online:\nIn the non-linear root finding, does the input dimension have to match the output dimensions?\nRight now I have input output dimension as 5, 4 respectively. input (5): (x, y, vx, vy, tend) output (4): (Δx, Δy, Δvx, Δvy )\nSomehow I feel this is not ideal. The system of nonlinear equations feels under defined. So, to correct this I added the constraint of solution roots should start on the y axis, i.e x = 0\nIn my system this is equivalent to:\nf(z⃗₀, p) = begin\n    tol = 1e-12\n\n    u⃗₀ = z⃗₀[1:end-1]\n    tend = z⃗₀[end]\n\n    dynamics_prob = ProblemSetup.create_problem(ProblemSetup.ode!, u⃗₀, tend, p)\n    dynamics_sol = DifferentialEquations.solve(dynamics_prob; abstol=tol, reltol=tol, save_everystep=false)\n    u⃗ₜ = dynamics_sol.u[end]\n    Δu⃗ = u⃗ₜ - u⃗₀\n\n    phasecondition = u⃗₀[2] # crosses the x axis\n\n    # v⃗₀ = u⃗₀[3:4]\n    # limit = 0.1\n    # if LinearAlgebra.norm(v⃗₀) &lt; limit || tend &lt; 0.1\n    #     return zeros(5) .+ 1.0\n    # end\n    # return Δu⃗\n    return [Δu⃗; phasecondition]\nend\nBut now the root finder is giving me this warning and gets stuck:\n Warning: Interrupted. Larger maxiters is needed. If you are using an integrator for non-stiff ODEs or an automatic switching algorithm (the default), you may want to consider using a method for stiff equations. See the solver pages for more details (e.g. https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#Stiff-Problems).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:589\n┌ Warning: Potential Rank Deficient Matrix Detected. Attempting to solve using Pivoted QR Factorization.\n└ @ NonlinearSolveBaseLinearSolveExt ~/.julia/packages/NonlinearSolveBase/yZeYz/ext/NonlinearSolveBaseLinearSolveExt.jl:33\n┌ Warning: At t=1.619487808996462e18, dt was forced below floating point epsilon 256.0, and step error estimate = 1.7742389634428446. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:623\n┌ Warning: Interrupted. Larger maxiters is needed. If you are using an integrator for non-stiff ODEs or an automatic switching algorithm (the default), you may want to consider using a method for stiff equations. See the solver pages for more details (e.g. https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#Stiff-Problems).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:589\n┌ Warning: Potential Rank Deficient Matrix Detected. Attempting to solve using Pivoted QR Factorization.\n└ @ NonlinearSolveBaseLinearSolveExt ~/.julia/packages/NonlinearSolveBase/yZeYz/ext/NonlinearSolveBaseLinearSolveExt.jl:33\n┌ Warning: At t=1.619487808996462e18, dt was forced below floating point epsilon 256.0, and step error estimate = 1.7742389634428446. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:623\nIs this because the phasecondition is linearly dependent to the state vector, I don't feel that is the case. What is going on?\nThe answer I got was by @romanveltz: “BifurcationKit does all that already”.\n\n\nTODO: Explore how BifurcationKit.jl achieves non-linear root finding.\nWe can formulate the solution to this either in an optimization way, or a root finding way.\nOne way to feed the initial conditions to the root solver is to keep doubling the norm of the initial condition vector, this is to avoid trivial roots: \\(tend = 0\\) or \\(v_0 = 0\\)\nIn julia, I use the NonlinearSolver. In file ./CentralForce/src/RootFinding.jl:\nfunction strategy_exponentiate()\n    randunitvec() = begin\n        θ = 2π*rand()\n        r = √(rand())\n        r*[cos(θ); sin(θ)]\n    end\n    \n    \n    tend_limit = 16000\n    v₀_limit = 1600\n    tend_init = 1.0\n    v₀_init = 1.0\n    factor = 2\n    periodic_sol = Vector{Float64}(undef, 5)\n    istrivial_tend_init = true\n    istrivial_v₀_init = true\n    varsinlimit() = begin\n        ((tend_init &lt; tend_limit) && (v₀_init &lt; v₀_limit))\n    end\n    varstrivial() = begin\n        (istrivial_tend_init || istrivial_v₀_init)\n    end\n    while varsinlimit() && varstrivial()\n        # local tend_init, istrivial_tend_init, v₀_init, istrivial_v₀_init, periodic_sol\n    \n        u⃗₀_init = [100*randunitvec(); v₀_init * randunitvec()]\n        z⃗₀_init = [u⃗₀_init; tend_init]\n    \n        root_prob = NonlinearSolve.NonlinearProblem(RootFinding.f, z⃗₀_init, ProblemSetup.p)\n        root_sol = NonlinearSolve.solve(root_prob)\n        println(\"Solver status: \", root_sol.retcode)\n        println(\"Residual norm: \", LinearAlgebra.norm(root_sol.resid))\n        u⃗₀_sol = root_sol[1:end - 1]\n        tend_sol = root_sol[end]\n        v⃗₀_sol = u⃗₀_sol[3:4]\n        v₀_sol = LinearAlgebra.norm(v⃗₀_sol)\n        println(\" ; root:tend_sol \", tend_sol, \" ; root:v₀_sol \", v₀_sol)\n        lowerlimit = 0.1\n        istrivial_tend_init = (tend_sol &lt; lowerlimit)\n        istrivial_v₀_init = (v₀_sol &lt; lowerlimit)\n        if varstrivial()\n            tend_init *= factor\n            v₀_init *= factor\n        else\n            println(\"Congratulations, found non-trivial periodic orbit\")\n            periodic_sol = root_sol\n        end\n        println(\"something trivial? : \", varstrivial())\n    end\n    \n    # periodic_sol = \n    # u⃗₀_periodic = periodic_sol[1:4]\n    # tend_periodic = periodic_sol[5]\n    # # plot the periodic solution\n    # plot_solution(ode!, u⃗₀_periodic, tend_periodic, p)\n    return periodic_sol\nend\nAnother strategy is to sample and pass every point in a mesh as a initial state to the solver, in the same file\nfunction strategy_meshcheck()\n    K = 100.0\n    N = 10\n    meshrange = range(-K, K, N)\n    meshtime = range(0.0, K, N)\n    count = 0\n    roots = []\n    println(\"Hello\")\n    for x in meshrange\n        for y in meshrange\n            for vx in meshrange\n                for vy in meshrange\n                    for t in meshtime\n                        global count\n                        r = LinearAlgebra.norm([x;y])\n                        v = LinearAlgebra.norm([vx;vy])\n                        if r &lt; 1.0 || v &lt; 1.0 || t &lt; 1.0\n                            println(\"skipping small cases\")\n                            continue\n                        end\n                        z⃗₀_init = [x; y; vx; vy; t]\n\n                        root_prob = NonlinearSolve.NonlinearProblem(RootFinding.f, z⃗₀_init, ProblemSetup.p)\n                        println(z⃗₀_init)\n                        root_sol = NonlinearSolve.solve(root_prob)\n\n                        count += 1\n                        percentage = 100*count / (N^length(z⃗₀_init))\n                        println(percentage, \"% completed\")\n\n                        if root_sol.retcode == NonlinearSolve.ReturnCode.Success\n                            push!(roots, root_sol)\n                        end\n                    end\n                end\n            end\n        end\n    end\n    println(\"Successfuly converged solutions: \", roots)\nend\nThe root finder was not converging for me for these.\nBut still with a bit of intuition I was able to find a non trivial Central Force Field with a non trivial periodic orbit, ./CentralForce/src/Physics.jl:\nFor the following force field:\n#...\nfunction hillinvalley(r⃗, p)\n    r = norm(r⃗)\n    σ = 5\n    a = 5\n    e = a*exp(-σ*r^2)\n    p = r^2\n    F = e+p #-a\nend\n#...\nThe graph of the magnitude of this force field:\n\n\n\nproblem11-hillinvalley-graph.png\n\n\nWith the follwoing intiial conditions, in file ./CentralForce/src/CentralForce.jl:\n#...\ntol = 1e-12\nfunction plot_solution(u⃗₀, tend)\n    ode_prob = ProblemSetup.create_problem(ProblemSetup.ode!, u⃗₀, tend, ProblemSetup.p)\n    sol = DifferentialEquations.solve(ode_prob, DifferentialEquations.Tsit5(); abstol=tol, reltol=tol, saveat=0.01)\n    trajectory = Visualization.plot_trajectory(sol)\n    GLMakie.save(\"./trajectory-solution.png\", trajectory)\n    GLMakie.display(trajectory)\nend\n#...\ntend = 50000.0\nr⃗ = [5, 5]\nv = 5.4225\nv⃗ = [-v, v]\nu⃗₀ = [r⃗; v⃗]\nplot_solution(u⃗₀, tend)\nWe get the surely periodic orbit, ‘surely periodic’ meaning I dont have an analytical proof yet but have tested it for tend=5000:\n\n\n\nproblem11-hillinvalley-trajectory.png\n\n\nThe inconsistent use of code blocks and \\(math blocks\\) was an intentional fast.",
    "crumbs": [
      "Solutions",
      "problem11"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem13/index.html",
    "href": "content/DynamicsSimulations/solutions/problem13/index.html",
    "title": "problem13",
    "section": "",
    "text": "13. Statics vs Dynamics. 2D. Equilibrium and dynamics of a point mass \\(m\\) at \\(\\vec{r}_{C}\\). Gravity \\(g\\) points down in the minus \\(\\hat{j}\\) direction. Points A and B are anchored at \\(\\vec{r}_A\\) and \\(\\vec{r}_B\\). Springs and parallel dashpots connect the mass to A and B. The spring constants are \\(k_A\\) and \\(k_B\\). Their rest lengths are \\(L_A\\) and \\(L_B\\). Parallel to the springs are dashpots \\(c_A\\) and \\(c_B\\). The mass also has a drag force proportional to speed through the air \\(c_d\\).\nThe dynamic state of the system is described with \\(z = [x, y, \\dot{x}, \\dot{y}]'\\) and the static state by \\(z = [x, y, 0, 0]'\\).\n\nBasic Statics. Given parameters and an initial guess, find an equilibrium position of this system. If you have an example you like, post it and people can compare solutions.\nBasic Dynamics. Given parameters and an initial condition, find the motion.\nAll equilibria. Given parameters, attempt to find all equilibria. How many are there? By varying parameters, what is the most and least number of equilibrium points there can be?\nStability of equilibrium. Given an equilibrium point, find it’s stability 2 ways: (a) With a dynamic simulation near the equilibrium; and (b) looking at the eigenvalues of the matrix describing the linearized equations of motion. Compare.\n\nMake appropriate plots, animations and comparisons.\n\nIn file ./FindEquilibrium/src/FindEquilibrium.jl:\nmodule FindEquilibrium\n\nimport DifferentialEquations\nimport GLMakie\n\ninclude(\"./Physics.jl\")\ninclude(\"Visualization.jl\")\n\nstruct SpringParameters\n    k::Float64          # constant\n    l::Float64          # restlen\n    r⃗₀::Vector{Float64} # anchor point\n    c::Float64          # damp: dashpot\nend\n\nstruct Parameters\n    m::Float64\n    g::Float64\n    c_d::Float64\n    spring1::SpringParameters\n    spring2::SpringParameters\nend\n\np = Parameters(\n    (global m = 0.1),\n    (global g = 0.1),\n    (global c_d = 0.5),\n    (global spring1 = SpringParameters(\n        (global k1=2.0),\n        (global l1=2.0),\n        (global r⃗₁=[1.0, 0.0]),\n        (global c1=1.0),\n        )\n    ),\n    (global spring2 = SpringParameters(\n        (global k2=1.0),\n        (global l2=0.5),\n        (global r⃗₂=[-1.0, -1.0]),\n        (global c2=1.0),\n        )\n    ),\n)\n\ntspan = (\n    (global tstart=0.0),\n    (global tend=200.0)\n)\n\nu⃗₀ = [\n    (global r0=[-1.0;1.0]);\n    (global v0=[10.0;5.0]);\n]\n\nodefunc = Physics.twospringsdragdamped!\nodeprob = DifferentialEquations.ODEProblem(\n    odefunc,\n    u⃗₀,\n    tspan,\n    p,\n    )\n\nΔt = 0.1\n\ntrajectory = GLMakie.Figure()\ntrajectory_lines = GLMakie.Axis(\n    trajectory[1,1],\n    title=\"Trajectory\",\n    aspect=GLMakie.DataAspect(),\n)\n\ni = [1.0;0.0]\nj = [0.0;1.0]\nN, n = 30, 5\nΔr⃗₀s = (global ϵ=0.01)*[cos(θ)*i+sin(θ)*j for θ in range(0.0; step=2π/N, length=n)]\n\nΔd = abs.(r⃗₁ - r⃗₂)\nfor x in range(min(r⃗₁[1], r⃗₂[1]) - Δd[1], max(r⃗₁[1], r⃗₂[1]) + Δd[2], length=N)\n    for y in range(min(r⃗₁[2], r⃗₂[2]) - Δd[2], max(r⃗₁[2], r⃗₂[2]) + Δd[2], length=N)\n        u⃗₀ = [\n            [x;y];\n            [0.0;0.0];\n        ]\n        for Δr⃗₀ in Δr⃗₀s\n            u⃗₀_modified = u⃗₀ + [Δr⃗₀; Δr⃗₀]\n            odeprob = DifferentialEquations.ODEProblem(\n                odefunc,\n                u⃗₀_modified,\n                tspan,\n                p,\n            )\n            sol = DifferentialEquations.solve(\n                odeprob; \n                # saveat=Δt,\n                save_everystep=false,\n                )\n            # Visualization.plot_trajectory!(trajectory, sol)\n            # Visualization.plot_start_end!(trajectory, sol)\n            Visualization.plot_end!(trajectory, sol)\n        end\n    end\nend\nVisualization.plot_points!(trajectory, spring1.r⃗₀, spring2.r⃗₀)\n\nend # module FindEquilibrium\n\n(a) Basic Statics. Given parameters and an initial guess, find an equilibrium position of this system. If you have an example you like, post it and people can compare solutions.\nFinally, taking the average of the two clusters of end points gives us these equilibrium state.\n[[-0.8, -0.49],[-0.6, -1.8]]\nNote, The axis aspect are not equal.\n\n\n\n(b) Basic Dynamics. Given parameters and an initial condition, find the motion.\nIn file ./FindEquilibrium/src/Physics.jl:\nmodule Physics\n\nimport LinearAlgebra: norm, normalize, dot\n\nfunction twospringsdragdamped!(du, u, p, t)\n    m, g, c_d, spring1, spring2 = p.m, p.g, p.c_d, p.spring1, p.spring2\n\n    r⃗ = u[1:2]\n    v⃗ = u[3:4]\n    a⃗ = begin\n        gravity = begin\n            j = [0.0;1.0]\n            m*g*(-j)\n        end\n        drag = begin\n            v = norm(v⃗)\n            v̂ = v⃗/v\n            (c_d*v)*(-v̂)\n        end\n        spring1 = begin\n            spring = begin\n                Δr⃗ = r⃗ - spring1.r⃗₀\n                Δr = norm(Δr⃗)\n                Δl = Δr - spring1.l\n                Δr̂ = Δr⃗ / Δr\n                (spring1.k*Δl)*(-Δr̂)\n            end\n            dashpot = begin\n                r̂ = normalize(r⃗)\n                (spring1.c*dot(v⃗, r̂))*(-r̂)\n            end\n            spring+dashpot\n        end\n        spring2 = begin\n            spring = begin\n                Δr⃗ = r⃗ - spring2.r⃗₀\n                Δr = norm(Δr⃗)\n                Δl = Δr - spring2.l\n                Δr̂ = Δr⃗ / Δr\n                (spring2.k*Δl)*(-Δr̂)\n            end\n            dashpot = begin\n                r̂ = normalize(r⃗)\n                (spring2.c*dot(v⃗, r̂))*(-r̂)\n            end\n            spring+dashpot\n        end\n        F = +gravity+drag+spring1+spring2\n        F/m\n    end\n\n    du[1:2] = v⃗\n    du[3:4] = a⃗\nend\n\nend # module Physics\nAn example trajectory for the taken parameters:\n\n\n\n(c) All equilibria. Given parameters, attempt to find all equilibria. How many are there? By varying parameters, what is the most and least number of equilibrium points there can be?\nWhat I did essentially was to take many (about 300) intial position vectors in a grid around the and containing the anchor points. I tried various methods, but essentially all of the methods revolved around playing the simulation and noting the end point. Look at some of the plots below:\n\n\n\nTrying to use a negative air drag:\n\n\nFinally, just looking at the start state and the end state:\n\n\n\n\n(d) Stability of equilibrium. Given an equilibrium point, find it’s stability 2 ways: (a) With a dynamic simulation near the equilibrium; and (b) looking at the eigenvalues of the matrix describing the linearized equations of motion. Compare.\nI was only able to find stable equilibriums. I was not able to use “(b) looking at the eigenvalues of the matrix describing the linearized equations of motion.”\nThis concludes my attempt of problem13.",
    "crumbs": [
      "Solutions",
      "problem13"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem15/index.html",
    "href": "content/DynamicsSimulations/solutions/problem15/index.html",
    "title": "problem15",
    "section": "",
    "text": "15. Potential Energy. For each of the force fields below, find the associated potential energy function. All of them are 3D. In some cases the energy is associated with the positions of two particles. Any free constant can be set to a convenient value (like zero). The answers are easy, it sometimes takes careful multi-variable calculus to find or check them.\n\nConstant force \\(\\vec{F} = -mg\\hat{j}\\). (Ans: \\(E_p = mgy\\))\nZero-rest-length spring, one end at origin \\(\\vec{F} = -kr\\hat{e}_r = -k \\vec{r}\\). (Ans: \\(E_p = kr^2/2\\))\nSpring, one end at origin \\(\\vec{F} = -k(\\ell - \\ell_0) \\hat{e}_r\\). (Ans: \\(E_p = k(\\ell - \\ell_0\\))\nInverse sqaure central force \\(\\vec{F} = -C \\vec{r}/r^3\\). (Ans: E_p = -C/r)\nCentral force, depending on r, \\(\\vec{F} = -f(r)\\hat{e}_r\\). (Ans: \\(\\int\\limits_{r_0}^{r}f(r')dr'\\), with with \\(r_0\\) chosen so integral is not divergent)\nSpring between two points. (Ans: $E_p = -C/_{12})\nInverse square attraction between two points. (Ans: \\(E_p = -C/\\ell_{12}\\))\nConstant force \\(\\vec{F} = -C \\hat{\\lambda}\\). (Ans: \\(E_p = C \\vec{r} \\cdot \\hat{\\lambda}\\))\nForce in x direction only depending on x, \\(\\vec{F} = -f(x) \\hat{i}\\). (Ans: \\(\\int \\limits_{x_0}^x f(x')dx'\\), with \\(x_0\\) chosen so the integral is not divergent)",
    "crumbs": [
      "Solutions",
      "problem15"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem17/index.html",
    "href": "content/DynamicsSimulations/solutions/problem17/index.html",
    "title": "problem17",
    "section": "",
    "text": "17. Montgomery’s eight. (From Ruina/Pratap). Three equal masses, say \\(m = 1\\), are attracted by an inverse-square gravity law with \\(G = 1\\). That is, each mass is attracted to the other by \\(F = G m_1 m_2 / r^2\\) where \\(r\\) is the distance between them. Use these unusual and special initial positions:\n\\[\n\\begin{align*}\n(x1, y1) &= (−0.97000436, 0.24308753) \\\\\n(x2, y2) &= (−x1, −y1) \\\\\n(x3, y3) &= (0, 0)\n\\end{align*}\n\\]\nand initial velocities\n$$ \\[\\begin{align*}\n(vx3, vy3) &= (0.93240737, 0.86473146)\n(vx1, vy1) &= −(vx3, vy3)/2\n(vx2, vy2) &= −(vx3, vy3)/2.\n\\end{align*}\\]\nFor each of the problems below show accurate computer plots and explain any curiosities.\n\nUse computer integration to find and plot the motions of the particles. Plot each with a different color. Run the program for 2.1 time units.\nSame as above, but run for 10 time units.\nSame as above, but change the initial conditions slightly.\nSame as above, but change the initial conditions more and run for a much longer time.\n\n\n[Aside: This was discovered by both Richard Montgomery (Santa Cruz Math department) and also by ex-Cornell Physics PhD student Chris Moore (now at Santa FeInstitute), independently. And, I know both of them, independently.]",
    "crumbs": [
      "Solutions",
      "problem17"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/solutions/problem19/index.html",
    "href": "content/DynamicsSimulations/solutions/problem19/index.html",
    "title": "problem19",
    "section": "",
    "text": "19. What means “rate of change of angular momentum” for a SYSTEM of particles? You should master problem 14 before looking at this problem. Consider a system of moving particles with moving center of mass at G. Consider also a moving point C (moving relative to a Newtonian frame \\(\\mathcal{F}\\) that has an origin 0). For which of these definitions of \\(\\vec{H}_{/C}\\) Is the following equation of motion true (that is, consistent with \\(\\vec{F} = m\\vec{a}\\))?\n\\[\\vec{M}_C = \\dot{\\vec{H}}_{/C}\\]\nIn each case say whether the definition works i) in general, or ii) for some special cases (that you name) concerning the motions of P and C.\n\n\\(\\vec{H}_{/C} = \\sum \\vec{r}_{i/C'} \\times \\vec{v}_{i/C'}\\), where C’ is a point fixed in \\(\\mathcal{F}\\) that instantaneously coincides with C. (Hint: this definition is good one, always!)\n\\(\\vec{H}_{/C} = \\sum \\vec{r}_{i/C} \\times \\vec{v}_{i/0} m_i\\). (This strange definition is used in the classic, but in this case odd, Dynamics book by Housner and Hudson.)\n\\(\\vec{H}_{/C} = \\sum \\vec{r}_{i/C} \\times \\vec{v}_{i/C} m_i\\). (Hint: this is the most important candidate definition, but it’s only good for special kinds of C, namely: C = COM, C is fixed and …?)\n\nThat is, for each possible definition of \\(\\vec{H}/C\\) you need to calculate \\(\\dot{\\vec{H}}_{/C}\\) by differentiation and see if and when you get \\(\\sum \\vec{r}_{i/C} \\times \\vec{a}_{i/0} mi\\). If you are short for time just consider cases (a) and (c) and note their agreement if C is stationary or if C=G. Students in 5730 are expected to do a competent clear job of all three parts.",
    "crumbs": [
      "Solutions",
      "problem19"
    ]
  },
  {
    "objectID": "content/Resources/index.html",
    "href": "content/Resources/index.html",
    "title": "Resources",
    "section": "",
    "text": "The resources are not just dead links, rather something I have grapelled and interacted with. This page is not meant for things I have not interacted with and will not in the near future (those are meant for [[syllabus]]. Keeping this in mind, I am still envisioning the exact interface and implementation of this database. The root of the debate is that each interaction has an entry point (topic/index.qmd) with mutliple urls, contributors, meta links spread over the page. The current debated ideas are, in usage chronology:\n\nYaml metadata. (rigid, need to modify)\nEntry point with modified. (free flowing, flexible)\n\nMany (not all) are meant to be a log of my interaction with that resource. Interaction has three integral parts as of now. These are Insights, References, Meta. Inside the References, there may be many Nodes. Each Node has its own urls, contributors, status. Each node may also have categories (format).\nIt just occurred to me: I love resource-sharing discord channels. They have pinned messages plus they have ongoing chat which is in the form of a log.\n\n\n\n\n\n\nI have not explored/read everything listed out here: if something is here, it just means that I am vaguely aware of said thing. Things I have some appreciation for are marked with a  and can be filtered by typing parsed in the search box on this page. Things I have passing or partial familiarity with are marked with a  and can be filtered by typing pseudo in the search box on this page.\nTo filter by tags, enter one of the following in the search box:\nprobability • logic • paper • folding • cutting • tiling • graphs • game • chess • geometry • card\n\n\n\n\nhttps://arxiv.org/pdf/1502.03808\nhttps://www.youtube.com/watch?v=eKzHKGVIZMk\nhttps://transformer-circuits.pub/2025/attribution-graphs/biology.html\n\n \n\n\n\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Categories\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\nDescription\n\n\n\nCategories\n\n\n\n\n\n\n\n\nClang\n\n\nThe Overlord Languge and Necromancer of Old CPUs\n\n\n\n\n\n\n\n\n\nEmacs\n\n\nThoughts and References when Learning Emacs.\n\n\n\n\n\n\n\n\n\nOCaml\n\n\nLoved, Used, Ideal Functional Programming Language\n\n\n\n\n\n\n\n\n\nPage Rank\n\n\nThoughts and References when Learning Page Rank.\n\n\nA-Computing, B-LinearAlgebra\n\n\n\n\n\n\nThe Odin Project\n\n\n\n\n\n\n\n\n\n\n\n\nTopics on Tournament\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Content",
      "Resources"
    ]
  },
  {
    "objectID": "content/Resources/materials/emacs/index.html",
    "href": "content/Resources/materials/emacs/index.html",
    "title": "Emacs",
    "section": "",
    "text": "References\n\n\n\n\n\n\nLearners don’t Disable Emacs Menu Bar §\n\n\n\n\n\nGood advice, but I haven’t used the menu bar in the 3 days I have been using emacs. I went cold turkey.\n\n\n\n\n\n\n\n\n\nReplacing tmux and GNU screen with Emacs §\n\n\n\n\n\n\nEmacs can accomplish nearly everything your terminal multiplexer can do.\n\nThis is the promise of Emacs after all.\n\n\n\n\n\n\n\n\n\nGNU Readline §\n\n\n\n\n\nC-t, M-t transpose chars, did not work for me.\nC-_, C-x C-u and from manual C-? and C-M-_ also, reverses, confusing.\nC-x C-x Swap point and mark, seems useful for viw/mi&lt; eg. aprntly op says “means it’s not really such a useful thing to know about.”, hehe, because he says “have to remember where the mark is! This is like Emacs before M-x transient-mark-mode became a thing.”\nC-], M-C-] Character search forward/backward, nice i use this a lot in modal editing.\nM-# Insert a comment, hehe alt+shift bound to kb-layout chng. Ya: op says “in a line editor where commenting out a line has narrow applications.”\nC-c C-l Clear screen, redemption!\nC-q or C-v Quoted insert, what is this, does not work in python repl for me. Oh: op says “ANSI control codes. To insert ^[, type C-q ESC.”, still doesn’t work for me in python repl.\napparently, gglng op’s name refers wiki on Charles Bronson (prisoner) wow apparently [[tom-hardy]] did a bio-pick. added to [[sylabus]]\nmacro recording in line editor, neat, does not seem to be working for python repl\nM-* conflict of key bindings (alt+shift=kb layout change) on my end, can’t test this.\nwow, op says “NOTE: If C-s freezes your terminal, you can blame the superannuated “flow control” feature — it stops the flow of text so you can pause at will and read it. Wonderful feature in the 1980s when your teletype would type faster than you could read the text. Less so today.”\nM-. last argument of previous command appended to point.\nC-M-f prints out all known functions; C-M-v all known variables.\nnice read\n\n\n\n\n\n\n\n\n\nEffective Editiing Movement §\n\n\n\n\n\nSo far, the keybindings look all right for cursor navigation. For text selection and modification the keybindings suck so far. Common things:\n\nselecting end of word and WORD, as in vi\nselecting inside paranthesis\nmoving by treesitter nodes\nvisual mode, so far, with C-Space sucks\n\nLets see what this article has got.\n\n\n\n\n\n\n\n\n\nIntroduction to IDO Mode §\n\n\n\n\n\nAdds fuzzy finding. That means if you were to search for the buffer “Customize Group: Foobar” without Ido you’d have to contort your fingers and type the *, then TAB (and hope it completes) and if not, type in some more; then rinse and repeat.\nM-n, M-p Cycles through the next or previous work directories. I like this feature for completion for dired.\nThis IDO article makes me feel emacs has so much complexity for suppose a simple completion usecase. Fuzzy finding?\nI hate that find-file does not open dired when using IDO. Turning it off because of that.\n\n\n\n\n\n\n\n\n\nUnderstanding Minibuffer Completion §\n\n\n\n\n\nWent mostly over my head. I did not understand any foundational thing. Felt complicated and unnecssary emacs history made it more confusing. Did not feel useful.\n\n\n\n\n\n\n\n\n\nPractical Intro, insights hackability around emacs lisp §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEmacs Tutorial\n\n\n\n\n\nC-u Num Command: Usually command repeat, but sometimes argument to command. Example, C-u 2 C-l.\nM-e: Going to the end of sentence. This is a nice motion, I will use this for motion in code for now.\nM-y: after C-y Clipboard. Whoa, necromancer.\nSelf intersecting commands? C-/ groups of 20?\nSeveral buffers, but only one of them is “current” and editable at a time.\nC-x: A gateway shortcut to many maned eXtended command and they don’t make sense to me. In vi-like editors, : enters command. To shorten cumbersome commands there are aliases, so this doesn’t make sense to me. Why do I need to press something like C-x C-s or C-x C-f or C-x C-b instead of &lt;Space&gt; w or &lt;Space&gt; f &lt;Space&gt; b (no normal mode in emacs, space will be inserted)? Space mode also has discoverabilty. At this point I might as well do some jutsu:\n\n\n\nJutsu\n\n\n{Command Set}x{Editing Modes}: this is nice, achieved by “modes” in emacs is not present.\nOnly one major mode many minor modes at a time. e.g auto-fill-mode",
    "crumbs": [
      "Materials",
      "Emacs"
    ]
  },
  {
    "objectID": "content/Resources/materials/page-rank.html",
    "href": "content/Resources/materials/page-rank.html",
    "title": "Page Rank",
    "section": "",
    "text": "The Page Rank algorithm is a method for measuring the importance of website pages…\n\n\nAt its heart, PageRank works by counting the number and quality of links to determine an estimate of how important a website is…\n\n\n\nThe mathematical formulation of PageRank involves a probability vector and a transition matrix…",
    "crumbs": [
      "Materials",
      "Page Rank"
    ]
  },
  {
    "objectID": "content/Resources/materials/page-rank.html#core-concept",
    "href": "content/Resources/materials/page-rank.html#core-concept",
    "title": "Page Rank",
    "section": "",
    "text": "At its heart, PageRank works by counting the number and quality of links to determine an estimate of how important a website is…",
    "crumbs": [
      "Materials",
      "Page Rank"
    ]
  },
  {
    "objectID": "content/Resources/materials/page-rank.html#mathematical-formulation",
    "href": "content/Resources/materials/page-rank.html#mathematical-formulation",
    "title": "Page Rank",
    "section": "",
    "text": "The mathematical formulation of PageRank involves a probability vector and a transition matrix…",
    "crumbs": [
      "Materials",
      "Page Rank"
    ]
  }
]