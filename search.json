[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gyan’s sight",
    "section": "",
    "text": "This is Gyan’s PKM site.\n\n\n\n\n\n\n\n\n\n\n\n\nExpand To Learn About Gyan\n\n\n\n\n\nGyan (gyanantaran), is a creator therefore a learner. Read more about this site."
  },
  {
    "objectID": "content/Resources/turn-the-led-on/index.html",
    "href": "content/Resources/turn-the-led-on/index.html",
    "title": "Turn the LED on",
    "section": "",
    "text": "Contributed by @10kdiver.\n\n\n\nAnother fun probability puzzle:\n\n\nEach switch has a 50/50 chance of being ON or OFF.The switches are all independent of each other.What’s the probability that the LED is on? pic.twitter.com/idQnJRqFnL\n\n— 10-K Diver (@10kdiver) March 25, 2022"
  },
  {
    "objectID": "content/Resources/checkmate/index.html",
    "href": "content/Resources/checkmate/index.html",
    "title": "To Not Checkmate",
    "section": "",
    "text": "Curious puzzle by Karl Fabel. White to move and not checkmate:\n\n\n\nChessboard Position"
  },
  {
    "objectID": "content/DynamicsSimulations/problem10/index.html",
    "href": "content/DynamicsSimulations/problem10/index.html",
    "title": "problem10",
    "section": "",
    "text": "10. Mass hanging from spring. 3D. Consider a point mass hanging from a zero-restlength linear spring (`0 = 0) in a constant gravitational field.\na) Set up equations. Set up for numerical solution. Plot 2D projection of 3D trajectories.\nb) By playing around with initial conditions, find the most wild motion you can find (wild means most wiggles, or most complicated). Make one or more revealing plots. [Hint: Make sure the features you observe are properties of the system and not due to numerical errors. That is, check that the features do not change when the numerics is refined.]\nc) Using analytical methods justify your answer to part (b).\n\n\n\n../media/problem10/problem10.png\n\n\n\n\na. Plot 2D projection of 3D trajectories\nIn file ./SpringPendulum3D/src/Physics.jl\nfunction spring_pendulum3d!(du, u, p::Parameters.Param, t)\n    @unpack mass, gravity, stiffness, restinglen#=, viscosity=# = p\n\n    r⃗ = u[1:3]\n    v⃗ = u[4:6]\n\n    k = [0.0; 0.0; 1.0]\n    gravity = mass * gravity * (-k)\n    spring = stiffness * (norm(r⃗) - restinglen) * (-normalize(r⃗))\n    # drag = -viscosity * v⃗\n\n    force = (spring #=+ drag =#+ gravity)\n\n    du[1:3] = v⃗\n    du[4:6] = force / mass\nend\nThe 3D trajectories look like ellipses. For a particular set of parameters, given in the following\n\n\n\n../media/problem10/trajectory_plot.png\n\n\n# ...\n\n# problem setup\nx₀, y₀, z₀ = (1, 0, 0)\nr₀ = [x₀; y₀; z₀]\nv₀ = [0.0; 1.0; 0.0]\nu₀ = [r₀; v₀]\ntspan = (0.0, 10.0)\np = Parameters.Param(m = 1, g = 1, k = 2, l₀ = 0)\nprob = ODEProblem(Physics.spring_pendulum3d!, u₀, tspan, p)\n\n# ...\nThe 2D projection onto the xy, yz, zx respectively, are as follows:\n\n\n\n../media/problem10/trajectory_plot_projection.png\n\n\n\n\nb. Play around with initial conditions, and find the most wild motions\nI was not able to find any wild motions, other than numerical errors.\n\n\nc. Analytically justify answer to part (b)\nIf we look at the differential equations, it is equivalent to having three independent springs in the three mutually orthogonal directions with a constant shift in the ‘z-spring’ due to gravity.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem10"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem08/index.html",
    "href": "content/DynamicsSimulations/problem08/index.html",
    "title": "problem08",
    "section": "",
    "text": "8. Simplest dynamics with Polar coordinates. This is the simplest dynamics problem, but posed in polar coordinates. Assume a particle is on a plane with no force on it. So, you know it moves at constant speed in a constant direction. a. Write the differential equations \\(\\vec{a} = \\vec{0}\\) in polar coordinates. b. Solve them numerically for various initial conditions. c. Plot the solution and check that the motion is a straight line at constant speed. d. Using your numerical result, pick a way to measure how straight the path is, and see how straight a line your polar coordinate solution gives. You should define a quantitative measure of straightness, and then measure it with your solution. e. Is the path more straight when you refine the numerical tolerances.\n\n\na. Write differential equations in polar form\nWe finally get:\n\\[\\vec{a} = (\\ddot{r} - r\\omega^2)\\hat{e}_r + (2\\dot{r}\\omega + r\\dot{\\omega})\\hat{e}_\\theta = \\vec{0}\\]\nWe can break this down into two scalar differential equations of non-unity order,\n\\[ \\ddot{r} - r\\omega^2 = 0 \\]\n\\[ 2\\dot{r}\\omega + r \\dot{\\omega} = 0 \\]\nRearranging the terms\n\\[ \\ddot{r} =  r\\omega^2 \\]\n\\[ \\dot{\\omega} = - 2r^{-1}v_r\\omega \\]\nintroducing the state variable in the following way to reduce this into a first order vector differential equation, also we include \\(\\theta\\) to able to track it:\n\\[\\vec{z} =\n\\begin{bmatrix}\n    \\dot{r} \\\\\n    \\dot{v_r} \\\\\n    \\dot{\\theta} \\\\\n    \\dot{\\omega}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    v_r \\\\\n    r\\omega^2 \\\\\n    \\omega \\\\\n    - 2r^{-1}v_r\\omega \\\\\n\\end{bmatrix}\n\\]\nThe corresponding code for this ODE in file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Physics: ODE\nfunction aceleration_zero_polar!(du, u, p, t)\n    r  = u[1]\n    vᵣ = u[2] \n    θ  = u[3]\n    ω  = u[4]\n\n    du[1] = vᵣ\n    du[2] = r * ω^2\n    du[3] = ω\n    du[4] = -2 * r^(-1) * vᵣ * ω\nend\n\n\nb. Solve them numerically for various initial conditions\nSome trajectories and some animations for various initial sets of initial conditions look indeed like uniform motion.\nIn file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n # Problem setup\nr₀ = 2\nθ₀ = π/3\nv⃗ = [1;2]\n\nêᵣ = [cos(θ₀); sin(θ₀)]\nêₚ = [-sin(θ₀); cos(θ₀)]\n\nvᵣ₀ = dot(v⃗, êᵣ)\nvₚ₀ = dot(v⃗ - vᵣ₀ * êᵣ, êₚ)\n\nω₀ = vₚ₀ / r₀\n\nu₀ = [r₀; vᵣ₀; θ₀; ω₀]\ntspan = (0.0, 10.0)\np = nothing\n\nprob = ODEProblem(acceleration_zero_polar!, u₀, tspan, p)\n\n# Numerical solution\nΔh = 0.5\nsol = solve(prob, saveat=Δh, abstol=1, reltol=1)\n\n\nc. Plot the solution and check that the motion is a straight line at constant speed.\nIn file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Plotting trajectories\nfunction plot_trajectory_makie(sol)\n    # Convert solution to matrix form\n    sol_matrix = reduce(hcat, sol.u)'\n    \n    r = sol_matrix[:, 1]\n    θ = sol_matrix[:, 3]\n\n    r⃗ = r .* [cos.(θ) sin.(θ)]\n    x = r⃗[:, 1]\n    y = r⃗[:, 2]\n    xlimits = (minimum(x)-5, maximum(x)+5)\n    ylimits = (minimum(y)-5, maximum(y)+5)\n\n    ω = sol_matrix[:, 4]\n    vᵣ = sol_matrix[:, 2]\n    vₚ = ω .* r\n    v⃗ = [vᵣ vₚ]\n    s = norm.([v⃗[i, :] for i in 1:length(length(v⃗))])\n    t = sol.t\n    println(typeof(v⃗), size(v⃗), size(t), v⃗)\n\n    # Create figure\n    fig = GLMakie.Figure()\n    ax1 = GLMakie.Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\", limits=(xlimits, ylimits), aspect = DataAspect())\n    ax2 = GLMakie.Axis(fig[1, 2], xlabel=\"time\", ylabel=\"speed\", aspect = DataAspect())\n\n    GLMakie.lines!(ax1, x, y)\n    GLMakie.lines!(ax2, t, s)\n    GLMakie.save(\"problem08-trajectory.png\", fig)\n    GLMakie.display(fig)\n    return nothing\nend\nplot_trajectory_makie(sol)\nThe plots generated by this:\n\n\n\nTrajectory\n\n\nLeft: The position of particle, \\(x\\) vs \\(y\\), Right: The speed of particle, \\(\\|\\vec{v}\\|\\) vs \\(t\\)\n\n\nd. Define a metric to measure straightness, plot\nJust like problem03, we can either use an analog to slither, i.e. the root mean squared error, but that again would require a lot of computer memory, which corresponds to impossibility on my computer, hence the easiest way here is the tail_match.\nThe measure here is the euclidean norm from the expected end point:\n\\[\\mathbf{\\hat{p}} = r_0\\left(cos(\\theta_0)\\hat{i} + sin(\\theta_0)\\hat{j}\\right) + \\vec{v} \\Delta t\\]\n\\[e = \\texttt{norm}(\\mathbf{\\vec{p}}-\\mathbf{\\hat{p}})\\]\nThe code corresponding to this, in file ./SimplestDynamicsPolar/src/SimplestDynamicsPolar.jl:\n# Measuring straightness\nfunction norm_expected_straight_endpoint(p⃗)\n    Δt = tspan[2] - tspan[1]\n    v⃗_cartesian = vᵣ₀ .* êᵣ₀ + vₚ₀ .* êₚ₀\n    p̂ = r₀ .* [cos(θ₀); sin(θ₀)] .+ v⃗_cartesian .* Δt\n    s⃗ = p⃗ .- p̂\n    e = norm(s⃗)\n    return e\nend\nThe path is already very straight without refining \\(\\Delta h\\):\n\n\n\nError vs Step size\n\n\nThis sums up my attempt of problem08.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem08"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem06/index.html",
    "href": "content/DynamicsSimulations/problem06/index.html",
    "title": "problem06",
    "section": "",
    "text": "6. Spring and mass (2D). One end of of a negligible-mass spring (k, L0) is pinned to the origin, the other to a mass (m). There is gravity (g). Initial Conditions (ICs): The initial position is \\(\\vec{r}\\_0 = x\\_0\\hat{i} + y\\_0\\hat{j}\\), and the initial velocity is \\(\\vec{v}\\_0 = v\\_{x0}\\hat{i} + v\\_{y0}\\hat{j}\\). Motion starts at \\(t = 0\\) and ends at tend.\n(a) Find the Equations of Motion (EoM);  \n(b) Assume all parameters and IC’s above are given.  \n    i. Plot the trajectory of the mass.  \n    ii. Animate the trajectory of the mass.  \n(c) How many ways can you think of checking the numerical solution, find as manyas you can, and do the check. The list is started here:\n    i. k = 0, all else arbitrary: The motion is parabolic flight (including fallingstraight down as a special case) [Why? The system is then just ballisticsfrom freshman physics];\n    ii. x0 = 0, vx0 = 0, all else arbitrary: The motion stays on the y axis [Why?There is no force in the x direction if the mass is on the y axis. Becausethe initial velocity has no x component, the mass never leaves the y axis;\n    iii. g = 0,*v0 =*0, all else is arbitrary: The motion stays on a radial line. And,if the motion does not cross the origin, the motion is that of a harmonicoscillator (sinusoidal oscillations, check by plotting, say x vt t. [Why? Writethe EoM and EoMs in polar coordinates⇒ mr¨ = −k(r − L0) ⇒ the harmonic oscillator equation, mr¨∗ =−kr∗, where r∗ ≡ r − L0.\n    iv. L0 = 0, all else is arbitrary: ? . [Why? ? .] Hint, this onespecial case is problem 10, below.v. etc.vi. etc.vii. . . .  \n\nSince I already did all of this pretty much in problem 1. I will instead write a simple lorentz system and animate it here.\nIn file ./lorentz_system.jl:\nusing DifferentialEquations\nusing GLMakie\n\n# ----------------------------\n# Define the Lorenz System\n# ----------------------------\n# The Lorenz system is given by:\n#   dx/dt = σ (y - x)\n#   dy/dt = x (ρ - z) - y\n#   dz/dt = x y - β z\nfunction lorenz!(du, u, p, t)\n    σ, ρ, β = p\n    du[1] = σ * (u[2] - u[1])\n    du[2] = u[1] * (ρ - u[3]) - u[2]\n    du[3] = u[1] * u[2] - β * u[3]\nend\n\n# ----------------------------\n# Set Parameters, Initial Conditions, and Solve the ODE\n# ----------------------------\n# Typical parameter values for the Lorenz system:\np = (10.0, 28.0, 8/3)\nu0 = [1.0, 0.0, 0.0]  # initial condition\ntspan = (0.0, 40.0)   # simulation time\n\n# Set up the ODE problem and solve it.\nprob = ODEProblem(lorenz!, u0, tspan, p)\nsol = solve(prob, Tsit5(); saveat=0.01)\n\n# ----------------------------\n# Create the Animation with Makie\n# ----------------------------\n# Create a new scene with a 3D camera.\nscene = Scene(resolution = (800, 600), camera = campixel!)\n\n# Plot the full trajectory as a blue line.\nlines!(scene, sol[1, :], sol[2, :], sol[3, :],\n       color = :blue, linewidth = 1)\n\n# Initialize a red marker for the moving point.\n# We start with the first position.\npoint = scatter!(scene, [sol[1,1]], [sol[2,1]], [sol[3,1]],\n                 markersize = 15, color = :red)\n\n# Record the animation. Here, each frame updates the position of the point.\nrecord(scene, \"lorenz_animation.gif\", length(sol.t)) do i\n    # Update the marker position to the i-th solution point.\n    point[1].attributes[:positions][] = Point3f0(sol[1,i], sol[2,i], sol[3,i])\n    # Optionally, you can adjust the frame rate by pausing briefly:\n    sleep(0.001)\nend\n\nprintln(\"Animation saved as lorenz_animation.gif\")\nThis produces the following animation:\n\n\n\n../media/problem06/lorentz_attractor.gif\n\n\nThe code given on Makie.jl library website:\nusing GLMakie\n\nBase.@kwdef mutable struct Lorenz\n    dt::Float64 = 0.01\n    σ::Float64 = 10\n    ρ::Float64 = 28\n    β::Float64 = 8/3\n    x::Float64 = 1\n    y::Float64 = 1\n    z::Float64 = 1\nend\n\nfunction step!(l::Lorenz)\n    dx = l.σ * (l.y - l.x)\n    dy = l.x * (l.ρ - l.z) - l.y\n    dz = l.x * l.y - l.β * l.z\n    l.x += l.dt * dx\n    l.y += l.dt * dy\n    l.z += l.dt * dz\n    Point3f(l.x, l.y, l.z)\nend\n\nattractor = Lorenz()\n\npoints = Observable(Point3f[])\ncolors = Observable(Int[])\n\nset_theme!(theme_light())\n\nfig, ax, l = lines(points, color = colors,\n    colormap = :inferno, transparency = true,\n    axis = (; type = Axis3, protrusions = (0, 0, 0, 0),\n              viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))\n\nrecord(fig, \"lorenz_makie.gif\", 1:120) do frame\n    for i in 1:50\n        push!(points[], step!(attractor))\n        push!(colors[], frame)\n    end\n    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120)\n    notify(points)\n    notify(colors)\n    l.colorrange = (0, frame)\nend\nThis produces:\n\n\n\n../media/problem06/lorenz_makie.gif\n\n\nIs there a way to think about verifying lorentz system solutions? I haven’t thought through this yet.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem06"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem04/index.html",
    "href": "content/DynamicsSimulations/problem04/index.html",
    "title": "problem04",
    "section": "",
    "text": "4. Cross product: geometry vs components.\na) The geometric definition of crossproduct is this $\\vec{a} \\times \\vec{b}$ is a vector $\\vec{c}$ with magnitude $\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin\\theta_{ab}$ that is orthmorogonal to $\\vec{a}$ and $vec{b}$ in the direction given by the right hand rule. Use this definition to findan alternative geometric definition involving projection (namely: project $\\vec{b}$ onto theplane that is orthogonal to $\\vec{a}$; then stretch it by $\\vec{|a|}$; then rotate it $\\pi/2$ around the $\\vec{a}$ axis). Use that definition to show the distributive rule $\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$.  \nb) Then use the distributive rule to find the component formula for cross product,namely that $\\vec{a} \\times \\vec{b} = (a_2 b_3 − a_3 b_2)\\hat{e}_1 + (a_3 b_1 − a_1 b_3) \\hat{e}_2 + (a_1 b_2 − a_2 b_1)\\hat{e}_3$.  \nNote that, this distributive law implies that, for given \\(va \\times \\vec{v}\\) is a linear operator.That is \\(va \\times \\vec{v}\\) is a linear function fo \\(\\vec{v}\\). Later in the course we will use this to replacethe cross product with a tensor product. Hint: You can read about this in, say, theRuina/Pratap book (box 1.7).\n\nThe cross product \\(\\vec{a} \\times \\vec{b}\\) is defined geometrically as a vector \\(\\vec{c}\\) with magnitude \\(\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin \\theta_{ab}\\), direction orthogonal to both \\(\\vec{a}\\) and \\(\\vec{b}\\), and orientation following the right-hand rule. We can reformulate this using projection. First, project \\(\\vec{b}\\) onto the plane orthogonal to \\(\\vec{a}\\) using the formula \\(\\vec{b}_{\\perp} = \\vec{b} - (\\vec{b}\\cdot\\hat{a})\\hat{a}\\), where \\(\\hat{a}\\) is the unit vector in direction of \\(\\vec{a}\\). The magnitude of this projection is \\(\\|\\vec{b}\\_{\\perp}\\| = \\|\\vec{b}\\|\\sin \\theta\\)\nThen stretch this vector by \\(\\|\\vec{a}\\|\\), giving \\(\\|\\vec{a}\\|\\vec{b}\\_{\\perp}\\) with magnitude \\(\\|\\vec{a}\\|\\|\\vec{b}\\|\\sin \\theta\\). Finally, rotate this vector by \\(\\pi/2\\) around the \\(\\vec{a}\\) axis, which preserves magnitude while making the result orthogonal to both \\(\\vec{a}\\) and \\(\\vec{b}\\_{\\perp}\\) in the right-hand rule direction. This construction yields a vector identical to the original definition.\nTo prove distributivity, \\(\\vec{a} \\times (\\vec{b} + \\vec{c}) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}\\), we use this new geometric definition. When we project \\((\\vec{b} + \\vec{c})\\) onto the plane perpendicular to \\(\\vec{a}\\), linearity of projection gives us \\((\\vec{b} + \\vec{c})\\_{\\perp} = \\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}\\). Stretching by \\(\\|\\vec{a}\\|\\) is also linear: \\(\\|\\vec{a}\\|(\\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}) = \\|\\vec{a}\\|\\vec{b}\\_{\\perp} + \\|\\vec{a}\\|\\vec{c}\\_{\\perp}\\). Since rotation by \\(\\pi/2\\) is linear, \\(R\\_{\\pi/2}(\\vec{b}\\_{\\perp} + \\vec{c}\\_{\\perp}) = R\\_{\\pi/2}\\vec{b}\\_{\\perp} + R\\_{\\pi/2}\\vec{c}\\_{\\perp}\\), proving the distributive property.\nTo derive the component formula, we use distributivity: \\(\\vec{a} \\times \\vec{b} = (a\\_1\\hat{e}\\_1 + a\\_2\\hat{e}\\_2 + a\\_3\\hat{e}\\_3) \\times (b\\_1\\hat{e}\\_1 + b\\_2\\hat{e}\\_2 + b\\_3\\hat{e}\\_3) = \\sum\\_{i,j} a\\_ib\\_j(\\hat{e}\\_i \\times \\hat{e}\\_j)\\). Using the standard basis cross products (\\(\\hat{e}\\_1 \\times \\hat{e}\\_2 = \\hat{e}\\_3\\), \\(\\hat{e}\\_2 \\times \\hat{e}\\_3 = \\hat{e}\\_1\\), \\(\\hat{e}\\_3 \\times \\hat{e}\\_1 = \\hat{e}\\_2\\), \\(\\hat{e}\\_i \\times \\hat{e}\\_i = 0\\), \\(\\hat{e}\\_j \\times \\hat{e}\\_i = -(\\hat{e}\\_i \\times \\hat{e}\\_j)\\)), we expand and group terms to get the final component formula: \\(\\vec{a} \\times \\vec{b} = (a\\_2b\\_3 - a\\_3b\\_2)\\hat{e}\\_1 + (a\\_3b\\_1 - a\\_1b\\_3)\\hat{e}\\_2 + (a\\_1b\\_2 - a\\_2b\\_1)\\hat{e}\\_3\\).",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem04"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem02/index.html",
    "href": "content/DynamicsSimulations/problem02/index.html",
    "title": "problem02",
    "section": "",
    "text": "2. 3D. Get good at vectors. Assume that the positions relative to an origin of four random points, which are randomly located in space are given as \\(\\vec{\\mathbf{r}}_A\\), \\(\\vec{\\mathbf{r}}_B\\), \\(\\vec{\\mathbf{r}}_C\\) and \\(\\vec{\\mathbf{r}}_D\\). Assume force \\(\\vec{\\mathbf{F}}\\) is given. For each problem below write a single vector formula (one for each problem) that answers the question.\na) The points A and B define an infinite line. So do the points C and D. Find the distance between these two lines. ‘The’ distance means ‘the minimum distance’, that is the length of the shortest line segment connecting the two lines. Either write a formula (or sequence of formulas), or write computer code that gives the answer, or both.  \nb) Same problem as above, but also find the end points of the shortest line segment.  \nc) Find the volume of the tetrahedron ABCD (you should reason-out and not quote any formulas for the volume of a tetrahedron, that is, see if you can derive the formula: ’volume = one third base times height’).  \nd) Assume points A, B and C are fixed to a structure. All three are connected, by massless rods, to a ball and socket at each end, to point D. At point D the force  F is applied. Find the tension in bar AD. Find a formula for the answer, or write computer code to find the answer, or both. The goal is to find a formula for the tension in terms of the positions and the force vector.\n\n\nWrite formula or code for the length of the shortest line segment\nThe lines can be represented as:\n\\[l_1: \\vec{p}_1(\\lambda_1) = \\quad \\vec{\\mathbf{r}}_A + \\lambda_1 (\\vec{\\mathbf{r}}_B-\\vec{\\mathbf{r}}_A)\\]\n\\[l_2: \\vec{p}_2(\\lambda_2) = \\quad \\vec{\\mathbf{r}}_C + \\lambda_2 (\\vec{\\mathbf{r}}_D-\\vec{\\mathbf{r}}_C)\\]\nHence, for two points on either lines, \\(p_1\\), \\(p_2\\), the distance is:\n\\[D(\\lambda_1, \\lambda_2) = \\quad \\left|\\left| \\mathbf{\\vec{p}}_2 - \\mathbf{\\vec{p}}_1 \\right|\\right|_n\\]\nWhich can be framed as an optimisation problem, minimum length, \\(\\hat{s}\\):\n\\[\\hat{s} = \\quad \\min_{\\lambda_1, \\lambda_2} || \\left( \\vec{\\mathbf{r}}_A + \\lambda_1 (\\vec{\\mathbf{r}}_B-\\vec{\\mathbf{r}}_A) - (\\vec{\\mathbf{r}}_C + \\lambda_2 (\\vec{\\mathbf{r}}_D-\\vec{\\mathbf{r}}_C)) \\right) ||_n\\]\nor,\n\\[\\hat{s} \\leftarrow D\\left\\{ \\nabla D(\\lambda_1, \\lambda_2) = 0 \\right\\}\\]\nThe code corresponding to this in file ./MinimumDistanceBetweenTwoLines/src/MinimumDistanceBetweenTwoLines.jl is:\nmodule MinimumDistanceBetweenTwoLines\n\nimport Symbolics\nimport LinearAlgebra\n\n# problem setup\nconst N = 3\nSymbolics.@variables r⃗ₛ[1:N] r⃗ₜ[1:N] r⃗ᵤ[1:N] r⃗ᵥ[1:N]\nSymbolics.@variables λ₁ λ₂\n\np⃗₁ = r⃗ₛ + λ₁ * (r⃗ₜ - r⃗ₛ)\np⃗₂ = r⃗ᵤ + λ₂ * (r⃗ᵥ - r⃗ᵤ)\ns⃗ = p⃗₂ - p⃗₁\nD² = LinearAlgebra.dot(s⃗, s⃗)\nD² = Symbolics.scalarize(D²)\n∇D² = Symbolics.gradient(D², [λ₁, λ₂])\neq = ∇D² .~ 0\n\nlambdas_symbolic = Dict([λ₁, λ₂] .=&gt; Symbolics.symbolic_linear_solve(eq, [λ₁, λ₂]))\np̂₁_symbolic, p̂₂_symbolic = Symbolics.substitute.([p⃗₁, p⃗₂], Ref(lambdas_symbolic))\nŝ_symbolic = Symbolics.substitute.(D², Ref(lambdas_symbolic))\n\n#...\nNote that in the code, we are optimising for distance squared, and the \\(s\\) symbols in the code represent the distance squared.\nIn the same file, we take specific values:\n#...\n\n# evaluation\nsubs = Dict(\n    r⃗ₛ =&gt; [0.0, 0.0, 0.0],\n    r⃗ₜ =&gt; [1.0, 0.0, 0.0],\n    r⃗ᵤ =&gt; [0.0, 0.0, 1.0],\n    r⃗ᵥ =&gt; [0.0, 1.0, 2.0],\n    # λ₁ =&gt; 3,\n    # λ₂ =&gt; 4,\n)\n∇D²_eval = Symbolics.substitute.(∇D², Ref(subs))\n\neq_eval = Symbolics.substitute.(eq, Ref(subs))\n\nresult_eval = Dict(symbol =&gt; Symbolics.substitute(expresion, subs) for (symbol, expresion) in lambdas_symbolic)\nmerged_eval = merge(subs, result_eval)\n\nŝ_eval = Symbolics.substitute.(D², Ref(merged_eval))\np̂₁_eval, p̂₂_eval = Symbolics.substitute.([p⃗₁, p⃗₂], Ref(merged_eval))\n\nprintln(\"=== Substituted results: =====\")\nprintln(\"Λ̂  : \", result_eval)\nprintln(\"ŝ  = \", ŝ_eval)\nprintln(\"p̂₁ = \", p̂₁_eval)\nprintln(\"p̂₂ = \", p̂₂_eval)\n\nprintln(\"\\n=== Symbolic results: =====\")\nprintln(\"Λ̂  : \", lambdas_symbolic)\nprintln(\"ŝ  = \", Symbolics.scalarize(ŝ_symbolic))\nprintln(\"p̂₁ = \", Symbolics.scalarize(p̂₁_symbolic))\nprintln(\"p̂̂₂ = \", Symbolics.scalarize(p̂₂_symbolic))\n\nend # module MinimumDistanceBetweenTwoLines\nThis produces the following:\njulia&gt; include(\"src/MinimumDistanceBetweenTwoLines.jl\")\nWARNING: replacing module MinimumDistanceBetweenTwoLines.\n=== Substituted results: =====\nΛ̂  : Dict{Symbolics.Num, Float64}(λ₂ =&gt; -0.5, λ₁ =&gt; -0.0)\nŝ  = 0.5\np̂₁ = [0.0, 0.0, 0.0][Base.OneTo(3)]\np̂₂ = [0.0, -0.5, 0.5][Base.OneTo(3)]\n\n=== Symbolic results: =====\nΛ̂  : Dict{Symbolics.Num, SymbolicUtils.BasicSymbolic{Real}}(λ₂ =&gt; ((-(2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(⃗rₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-⃗rᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), λ₁ =&gt; ((-((-(2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)))\nŝ  = (r⃗ᵤ[1] - r⃗ₛ[1] + ((-r⃗ᵤ[1] + r⃗ᵥ[1])*(((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + (((((-(-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - ⃗rₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(r⃗ₛ[1] - r⃗ₜ[1])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)))^2 + (r⃗ᵤ[2] - r⃗ₛ[2] + (((((-(-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(r⃗ₛ[2] - r⃗ₜ[2])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[2] + r⃗ᵥ[2])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)))^2 + (r⃗ᵤ[3] - r⃗ₛ[3] + ((((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) - 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[3] + r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)))^2\np̂₁ = Symbolics.Num[r⃗ₛ[1] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(⃗rₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[1] + r⃗ₜ[1])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)), r⃗ₛ[2] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - ⃗rₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[2] + r⃗ₜ[2])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)), r⃗ₛ[3] + ((((((2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)) + 2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) + 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-r⃗ₛ[3] + r⃗ₜ[3])) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2))]\np̂̂₂ = Symbolics.Num[r⃗ᵤ[1] + ((-r⃗ᵤ[1] + r⃗ᵥ[1])*(((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-⃗rᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), r⃗ᵤ[2] + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[2] + r⃗ᵥ[2])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2)), r⃗ᵤ[3] + ((((-2(r⃗ᵤ[1] - r⃗ₛ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(r⃗ᵤ[2] - r⃗ₛ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(r⃗ᵤ[3] - r⃗ₛ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))*(-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) + 2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ᵤ[1] - r⃗ₛ[1]) + 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ᵤ[2] - r⃗ₛ[2]) + 2(r⃗ᵤ[3] - r⃗ₛ[3])*(-r⃗ᵤ[3] + r⃗ᵥ[3]))*(-r⃗ᵤ[3] + r⃗ᵥ[3])) / ((-((-2(-r⃗ᵤ[1] + r⃗ᵥ[1])*(r⃗ₛ[1] - r⃗ₜ[1]) - 2(-r⃗ᵤ[2] + r⃗ᵥ[2])*(r⃗ₛ[2] - r⃗ₜ[2]) - 2(-r⃗ᵤ[3] + r⃗ᵥ[3])*(r⃗ₛ[3] - r⃗ₜ[3]))^2)) / (-2((r⃗ₛ[1] - r⃗ₜ[1])^2) - 2((r⃗ₛ[2] - r⃗ₜ[2])^2) - 2((r⃗ₛ[3] - r⃗ₜ[3])^2)) - 2((-r⃗ᵤ[1] + r⃗ᵥ[1])^2) - 2((-r⃗ᵤ[2] + r⃗ᵥ[2])^2) - 2((-r⃗ᵤ[3] + r⃗ᵥ[3])^2))]\nMain.MinimumDistanceBetweenTwoLines\n\n\nAlso find the end points of the shortest line segment\nThe formulation above can be reused, the optimal lambdas \\(\\hat{\\Lambda} = (\\lambda_1, \\lambda_2)\\), correspond to the closest points through the equation of the lines.\n\\[\\left(\\hat{\\lambda}_1, \\hat{\\lambda}_2\\right) = \\underset{\\lambda_1, \\lambda_2}{\\texttt{argmin}} \\left\\{ D(\\lambda_1, \\lambda_2) \\right\\}\\]\nA specific example’s numerical output was given in the previous section.\n\n\nFind the volume of the tetrahedron\nFor any 2d shape extended to a point, the volume is \\(\\frac{1}{3} \\text{Base-Area} \\times \\text{height}\\). Why? Take a slice, the planar dimensions reduce linearly to zero, so the area reduces quadratically. Integrate the function for the area as a function of the height from base to the tip.\nThis way, we can see that a tetrahedron is geometric one-sixth of a parallelapiped, therefore, volume \\(V(\\vec{\\mathbf{r}}_a, \\vec{\\mathbf{r}}_b, \\vec{\\mathbf{r}}_c, \\vec{\\mathbf{r}}_d)\\) is (assuming the vectors are in three dimensions for cross product to work):\n\\[V(\\vec{\\mathbf{r}}_a, \\vec{\\mathbf{r}}_b, \\vec{\\mathbf{r}}_c, \\vec{\\mathbf{r}}_d) = \\frac{1}{6} \\left|(\\vec{\\mathbf{r}}_c - \\vec{\\mathbf{r}}_b) \\times (\\vec{\\mathbf{r}}_c - \\vec{\\mathbf{r}}_a) \\cdot (\\vec{\\mathbf{r}}_d - \\vec{\\mathbf{r}}_d)\\right|\\]\n\n\nWrite formula or code for the tensions in the rods\n\\[\\vec{\\mathbf{F}} + T_{ad}\\hat{r}_{ad} + T_{bd}\\hat{r}_{bd} + T_{cd}\\hat{r}_{cd} = \\vec{\\mathbf{0}}\\]\nThere was an in-class mention about Cramer’s rule to solve this. There are three equations and three unknowns, but one could use Gaussian-elimination.\nThe other way to solve this using vector algebra is to dot the whole equation with a vector which is perpendicular to two of the three tension vectors. For example by \\(\\hat{r}_{ad}\\).",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem02"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/index.html",
    "href": "content/DynamicsSimulations/index.html",
    "title": "Dynamics",
    "section": "",
    "text": "problem01\n\n\n \n\n\n\n\n\nJan 24, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem02\n\n\n \n\n\n\n\n\nJan 24, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem03\n\n\n \n\n\n\n\n\nJan 24, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem04\n\n\n \n\n\n\n\n\nFeb 4, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem05\n\n\n \n\n\n\n\n\nJan 24, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem06\n\n\n \n\n\n\n\n\nJan 24, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem07\n\n\n \n\n\n\n\n\nFeb 24, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem08\n\n\n \n\n\n\n\n\nFeb 25, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem09\n\n\n \n\n\n\n\n\nFeb 26, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem10\n\n\n \n\n\n\n\n\nMar 25, 2025\nVishal Paudel\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproblem11\n\n\n \n\n\n\n\n\nApr 2, 2025\nVishal Paudel\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Dynamics"
    ]
  },
  {
    "objectID": "content/Blog/posts/post-with-code/index.html",
    "href": "content/Blog/posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "content/Blog/about.html",
    "href": "content/Blog/about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "content/Blog/index.html",
    "href": "content/Blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Post With Code\n\n\n \n\n\nnews\n\ncode\n\nanalysis\n\n\n \n\n\n\n\n\nApr 21, 2025\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n \n\n\nnews\n\n\n \n\n\n\n\n\nApr 18, 2025\nTristan O'Malley\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/Blog/posts/welcome/index.html",
    "href": "content/Blog/posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "content/DynamicsSimulations/problem01/index.html",
    "href": "content/DynamicsSimulations/problem01/index.html",
    "title": "problem01",
    "section": "",
    "text": "1. Set up (define system, draw FBD, write ODEs) a particle problem. Just one particle. 2D or 3D, your choice. Use a force, or forces that you like (gravity, spring, air friction). Any example of interest. Find a numerical solution. Graph it. Animate it. Try to make an interesting observation.\n\n\nSystem Description and Free Body Diagram\nI think I have chosen a just hard enough interesting problem. A spring pendulum consists of a mass \\(m\\) attached to a spring of natural length \\(l_0\\) and spring constant \\(k\\).\nThe system experiences: - Spring force \\(\\vec{F_s} = k(\\|{\\vec{r}\\|}-l_0)(-\\hat{r})\\) - Gravitational force \\(\\vec{F_g} = mg(-\\hat{j})\\) - Damping force \\(\\vec{F_d} = cv(-\\hat{v})\\)\n\n\n\nFreebody-diagram\n\n\n\n\nEquations of Motion\nIn Cartesian coordinates, the equations of motion are:\n\\[\\dot{\\vec{r}} = \\vec{v}\\] \\[\\dot{\\vec{v}} = -k(\\|\\vec{r}\\|-l_0) \\hat{r} - c \\vec{v} - mg\\hat{j}\\]\nThe corresponding code for the ODE in file ./SpringPendulum/src/Physics.jl:\nmodule Physics\n\nusing ..Parameters\nusing LinearAlgebra\nusing UnPack\n\nexport spring_pendulum!\n\nfunction spring_pendulum!(du, u, p::Parameters.Param, t)\n    @unpack mass, gravity, stiffness, restinglen, viscosity = p\n\n    r⃗ = u[1:2]\n    v⃗ = u[3:4]\n\n    ĵ = [0.0; 1.0]\n    gravity = mass * gravity * (-ĵ)\n    spring = stiffness * (norm(r⃗) - restinglen) * (-normalize(r⃗))\n    drag = -viscosity * v⃗\n\n    force = (spring + drag + gravity)\n\n    du[1:2] = v⃗\n    du[3:4] = force / mass\nend\n\nend\n\n\nNumerical Solution\nIn file ./SpringPendulum/src/SpringPendulum.jl\nmodule SpringPendulum\n\nusing DifferentialEquations\n\ninclude(\"Parameters.jl\")\ninclude(\"Physics.jl\")\ninclude(\"Visualization.jl\")\n\n# problem setup\nx₀, y₀ = (1, 0)\nr₀ = [x₀;y₀]\nv₀ = [1.0;0.0]\nu₀ = [r₀;v₀]\ntspan = (0.0,25.0)\np = Parameters.Param(m=1,g=1,c=0.0,k=1,l₀=0)\nprob = ODEProblem(Physics.spring_pendulum!, u₀, tspan, p)\n\n# solver\nΔt = 0.001\nsol = solve(prob, saveat=Δt, reltol=1e-6, abstol=1e-6)\n\n# visualize\n# ...\n\nend # module SpringPendulum\n\n\nPhase Space Trajectory\nPlot showing the system evolution in phase space. In file ./SpringPendulum/src/Visualization.jl:\n\n\n\nLeft: Trajectory plot. Right: Theta vs Time\n\n\nCode corresponding to this in file SpringPendulum/src/Visualization.jl:\nfunction plot_trajectory(sol; title=\"Spring Pendulum Trajectory\")\n    a = reduce(hcat, sol.u)'\n    x =  a[:, 1]\n    y = a[:, 2]\n    θ = atan.(a[:, 2], a[:, 1])\n\n    xlimits = (minimum(x)-1, maximum(x)+1)\n    ylimits = (minimum(y)-1, maximum(y)+1)\n\n    trajectory_plot = Figure()\n    trajectory = Axis(trajectory_plot[1, 1],\n        title=title,\n        xlabel=\"X position\",\n        ylabel=\"Y position\",\n        limits=(xlimits, ylimits),\n        aspect=1,\n    )\n    lines!(trajectory, x, y,\n        label=\"Trajectory\",\n    )\n    axislegend(position=:rb)\n\n    trajectory = Axis(trajectory_plot[1, 2],\n        title=\"Theta vs time\",\n        xlabel=\"Time\",\n        ylabel=\"Theta\",\n    )\n    lines!(trajectory, sol.t, θ)\n\n    return trajectory_plot\nend\n\n\nAnimation\nThe following shows the animation for the solution system. The code corresponding to this animation:\n\n\nTODO: add springs to visualise\n\n\n\nSpring Pendulum Motion\n\n\nThe code corresponding to this animation is in file ./SpringPendulum/src/Visualization.jl:\nfunction makie_animation(sol; filename=\"sol_animation.gif\", title=\"Animation\")\n    sol_matrix = reduce(hcat, sol.u)'\n    x =  sol_matrix[:, 1]\n    y = sol_matrix[:, 2]\n    θ = atan.(sol_matrix[:, 2], sol_matrix[:, 1])\n\n    # coarse boundaries, for continuous(interpolated) boundary see: https://docs.sciml.ai/DiffEqDocs/stable/examples/min_and_max/\n    xlimits = (minimum(x)-1, maximum(x)+1)\n    ylimits = (minimum(y)-1, maximum(y)+1)\n\n    time = Observable(0.0)\n\n    x = @lift(sol($time)[1])\n    y = @lift(sol($time)[2])\n\n    # Create observables for line coordinates\n    line_x = @lift([0, $x])\n    line_y = @lift([0, $y])\n\n    animation = Figure()\n    ax = Axis(animation[1, 1], title = @lift(\"t = $(round($time, digits = 1))\"), limits=(xlimits, ylimits), aspect=1)\n\n    scatter!(ax, x, y, color=:red, markersize = 15)\n    lines!(ax, line_x, line_y, color=:black)\n\n    framerate = 30\n    timestamps = range(0, last(sol.t), step=1/framerate)\n\n    record(animation, filename, timestamps;\n            framerate = framerate) do t\n        time[] = t\n    end\n\n    return animation\nend\n\n\nObservations\n\nEnergy exchange between potential and kinetic forms\nDamped oscillations due to viscous friction\nFor some parameters there is weird behaviour at very small scales. This is probably an artifact of the solver and floating point truncations. I was unable to reproduce this, but I had shown this to Professor Andy and Ganesh Bhaiya.\nIncreasing c by a little has a drastic effect\nThe problem was fun to simulate\nJulia was fun to code in: Libraries were ergonomic to use, DifferentialEquations.jl, and Makie.jl\nI noticed only much later that all of the trajectories for when resting length is zero are elipses.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem01"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem03/index.html",
    "href": "content/DynamicsSimulations/problem03/index.html",
    "title": "problem03",
    "section": "",
    "text": "3. More ODE & animation practice. Take a simple set of ODEs. Use a set you like,e.g., harmonic oscillator, non-linear pendulum, the Lorentz system (look it up on the internet). Solve this set numerically 3 ways (see below), and understand the accuracy. The goal is that, by the time you hand in the homework, you can write and debug the assignment on your own without looking up anything (outside of trivial syntax things). And you always have a good sense of the accuracy of your solution.\na. Method 1: as simply as possible, without ODE45, and without calling functions or anything like that. A single function or script file with no function calls (ok, plotting calls are ok). Just write a simple loop that implements Euler’s method with your ODE.  \nb. With your own Euler solver function. Your main program should call your Euler solver. Your Euler solver should call a RHS (Right Hand Side) function.  \nc. With ODE45.  \nd. Using (b), solve the equations many times with progressively smaller step size, down to the smallest size you have patience for, and up to the largest size that isn’t crazy. As sensibly as possible, compare the results and use that comparison to estimate the accuracy of each solution. You should be able to find a method to estimate the accuracy of a numerical solution even without knowing the exact solution.  \ne. Using ODE45, solve the equations with various accuracies (use ’reltol’ and ’abstol’, note MATLAB satisfies one or the other, whichever is easiest. So, if you want an accurate solution you need to make both ’reltol’ and ’abstol’ small). Does Matlab do a good job of estimating its own accuracy? Use suitable plots to make your point.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem03"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem03/index.html#tailmatch-characterisation",
    "href": "content/DynamicsSimulations/problem03/index.html#tailmatch-characterisation",
    "title": "problem03",
    "section": "TailMatch Characterisation",
    "text": "TailMatch Characterisation\nThe ‘tailmatch’ is quite easily implemented in code, in file ./ODESolvers/src/Benchmarks.jl:\ntail_match(sol1::ProblemTypes.Solution, sol2::ProblemTypes.Solution)::ProblemTypes.AbsError = norm(sol2[end] - sol1[end])\nSince my current implementation saves updated state at each step, benchmarking for progressively reducing step sizes takes a lot of memory on top of time. I will update the euler solver to not save at each time step, benchmark at smaller step sizes later. For now, for the step size, I have gone till 1e-6 and the plot for the benchmark, with tail_match is as follows:\n\n\n\nStep sizes vs AbsError\n\n\n\n\nTODO: fix memory issue and go till 1e-15\nI have done some deep (very small) comparision of Midpoint and RK4 in ./problem09/README.md",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem03"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem03/index.html#slither-charaterisation",
    "href": "content/DynamicsSimulations/problem03/index.html#slither-charaterisation",
    "title": "problem03",
    "section": "Slither Charaterisation",
    "text": "Slither Charaterisation\nTo do this, we create some histories with different step sizes. I have skipped this for now.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem03"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem05/index.html",
    "href": "content/DynamicsSimulations/problem05/index.html",
    "title": "problem05",
    "section": "",
    "text": "5. Read up.\na. Read all of the course Teams posts so far, trying out all possible links of interest.  \nb. Make sure you thoroughly understand these sections of the Ruina/Pratap pdf book, available from Ruina’s www page:  \n   - Chapter 1 (read),\n   - Chapter 2 (skim, only study things you don’t know well already, make sure that within a few weeks you know all of this well. ),\n   - Chapter 3,\n   - Section 17.1,\n   - Appendix A.\nc. Write the following, if true, if not write that which is true:\n   &gt; “I have carefully done some of the reading assigned. That which I don’t understand or agree with, I have posted on the course Piazza site. I haven’t yet carefully read X [make appropriate substitutions for X]”.\n\nI have carefully done some of the reading assigned. That which I don’t understand or agree with, I have discussed in class. I haven’t yet carefully read Chapter 3, Section 17.1, Appendix A.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem05"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem07/index.html",
    "href": "content/DynamicsSimulations/problem07/index.html",
    "title": "problem07",
    "section": "",
    "text": "7. Simple animation of a shape. Draw a picture of some object (a face, a house, whatever), and make it move around on the screen in a smooth and interesting way. No distortions. Just motions and rotations\n\nIn file ./simple_animation.jl:\nusing GLMakie\n\n# Create a figure\nfig = Figure(resolution = (800, 600))\nax = GLMakie.Axis(fig[1, 1], aspect = DataAspect())\nlimits!(ax, -5, 5, -5, 5)\n\n# Define the house vertices (centered at origin)\nhouse_vertices = [\n    # Main square\n    Point2f(-1, -1), Point2f(1, -1), Point2f(1, 1), Point2f(-1, 1), Point2f(-1, -1),\n    # Roof\n    Point2f(-1, 1), Point2f(0, 2), Point2f(1, 1)\n]\n\n# Create initial lines object\nhouse_lines = lines!(ax, house_vertices, color = :blue, linewidth = 2)\n\n# Animation parameters\nframes = 300\nangular_speed = 2π/frames  # Complete one rotation\ndrift_speed = 4/frames    # Total drift distance\n\n# Create the animation\nrecord(fig, \"rotating_house.gif\", 1:frames; framerate = 30) do frame\n    # Calculate rotation and drift\n    angle = angular_speed * frame\n    drift_x = drift_speed * frame - 2  # Start from left side\n    drift_y = sin(2π * frame/frames)   # Add some vertical oscillation\n    \n    # Apply transformation to each point\n    transformed_points = [\n        Point2f(\n            x * cos(angle) - y * sin(angle) + drift_x,  # Rotation + horizontal drift\n            x * sin(angle) + y * cos(angle) + drift_y   # Rotation + vertical oscillation\n        )\n        for (x, y) in [(p[1], p[2]) for p in house_vertices]\n    ]\n    \n    # Update the lines object\n    house_lines[1] = transformed_points\nend\nProduces this animation:\n\n\n\nFloating house in space",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem07"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem09/index.html",
    "href": "content/DynamicsSimulations/problem09/index.html",
    "title": "problem09",
    "section": "",
    "text": "9. Canon ball. A cannon ball m is launched at angle θ and speed v0. It is acted on by gravity g and a viscous drag with magnitude \\(\\|c\n\\vec{v}\\|\\).\n(a) Find position vs time analytically.  \n(b) Find a numerical solution using θ = π/4, v0 = 1 m/s, g = 1 m/s 2 , m = 1 kg, c = 1 kg/ s.  \n(c) Compare the numeric and analytic solutions. At t = 2 how big is the error? How does the error depend on specified tolerances or step sizes?  \n(d) Use larger and larger values of v0 and for each trajectory choose a time interval so the canon at least gets back to the ground. Plot the trajectories (using equal scale for the x and y axis. Plot all curves on one plot. As v → ∞ what is the eventual shape? [Hint: the answer is simple and interesting.]  \n(e) For any given v0 there is a best launch angle θ ∗ for maximizing the range. As v0 → ∞ to what angle does θ ∗ tend? Justify your answer as best you can with careful numerics, analytical work, or both.  \n\n\n\n../media/problem09/problem09.png\n\n\n\n\nFind position vs time analytically.\nThe corresponding code for this in file ./Ballistics/src/Ballistics.jl:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    u = zeros((4,))\n    u[1] = vx0 * (-c/m) * (exp((-c/m)*(t-t0)) - 1)\n    u[2] = ((vy0+(m*g/c))*(-c/m)*(exp((-c/m)*(t-t0)) - 1)) + ((-m*g/c)*(t-t0))\n    u[3] = (vx0) * (exp((-c/m)*(t-t0)))\n    u[4] = ((vy0) + (m*g/c)) * exp((-c/m)*(t-t0)) - (m*g/c)\n\n    return u\nend\nThis turned out to be wrong, it was an integral mistake (integration mistake). The corrected version in the same file:\nfunction analytical_sol(t)\n    m, g, c = p.mass, p.gravity, p.viscosity\n\n    x = x0 + vx0 * ((-m / c) * exp((c / m) * (t0))) * (exp((-c / m) * t) - exp((-c / m) * t0))\n    y = y0 + ((vy0 + (m * g / c)) * (-m / c) * (exp((c / m) * t0)) * (exp((-c / m) * t) - exp((-c / m) * t0))) + ((-m * g / c) * (t - t0))\n    vx = (vx0) * (exp((-c / m) * (t - t0)))\n    vy = ((vy0) + (m * g / c)) * exp((-c / m) * (t - t0)) - (m * g / c)\n\n    u = zeros((4,))\n    u[1] = x\n    u[2] = y\n    u[3] = vx\n    u[4] = vy\n\n    return u\nend\n\n\nTODO: Could I have created this analytical solution symbolically?\n\n\nFind a numerical solution using given parameters\nThe corresponding code for this in file ./Ballistics/src/Ballistics.jl:\nusing DifferentialEquations\n#...\n# problem setup\nx0, y0 = 0.0, 0.0\nr0 = [x0; y0]\nspeed0 = 1\nlaunchangle = pi / 4\nvx0, vy0 = speed0 * [cos(launchangle); sin(launchangle)]\nv0 = [vx0; vy0]\nu0 = [r0; v0]\n\nt0 = 0.0\ntend = 1.0\ntspan = (t0, tend)\np = Parameters.Param(m=1, g=1, c=1)\nprob = ODEProblem(Physics.ballistic!, u0, tspan, p)\n#...\nsol_numeric = solve(prob)\n#...\nVisualization.plot_trajectory(sol_numeric.u)\nThis numerical solution gives the following trajectory:\n\n\n\n../media/problem09/numerical_trajectory.png\n\n\n\n\nCompare the numeric and analytics solutions? Plot time vs error. Plot step size and tolerances vs error.\nFor various initial conditions, the numeric and analytical solutions on the same graph, I was shifting the analytic in x direction by 0.1 unit to be able view both, otherwise they were overlapping with the default tolerances, but then I ended up using a non-dynamic step size explicit solver:\nIn file ./Ballistics/src/Benchmarks.jl:\nmodule Benchmarks\n\nusing DifferentialEquations\nusing LinearAlgebra\n\n# Abs error for various step sizes\nfunction abs_error_vs_step_sizes(prob, analytical_solve)\n    # step_sizes = 10.0 .^ range(-1, -15, step=-1)\n    step_sizes = 10.0 .^ range(-1, -5, step=-1)\n    abs_errors_midpoint = Vector{Union{Missing, Float64}}(missing, length(step_sizes))\n    abs_errors_rk4 = Vector{Union{Missing, Float64}}(missing, length(step_sizes))\n\n    for (i,Δh) in enumerate(step_sizes)\n        sol_numeric_midpoint = solve(prob, Midpoint(), dt=Δh, adaptive=false, save_everystep=false)[end]\n        sol_numeric_rk4 = solve(prob, RK4(), dt=Δh, adaptive=false, save_everystep=false)[end]\n        tend = prob.tspan[2]\n        sol_analytic = analytical_solve(tend)\n\n        separation_midpoint = sol_numeric_midpoint - sol_analytic\n        separation_rk4 = sol_numeric_rk4 - sol_analytic\n        error_midpoint = norm(separation_midpoint)\n        error_rk4 = norm(separation_rk4)\n    \n        abs_errors_midpoint[i] = error_midpoint\n        abs_errors_rk4[i] = error_rk4\n    end\n\n    log_errors_midpoint = log10.(abs_errors_midpoint)\n    log_errors_rk4 = log10.(abs_errors_rk4)\n    log_errors_dict = Dict(\"midpoint\"=&gt;log_errors_midpoint, \"rk4\"=&gt; log_errors_rk4)\n    log_steps = log10.(step_sizes)\n\n    return log_steps, log_errors_dict\nend\n\n# Abs error for all times\nfunction error_vs_time(prob, analytical_solve)\n    N = 5\n    step_sizes = 10.0 .^ range(-1, -N, step=-1)\n    time_histories = Vector{Union{Missing, Vector{Float64}}}(missing, length(step_sizes))\n    error_histories = Vector{Union{Missing, Vector{Float64}}}(missing, length(step_sizes))\n    for (i,Δh) in enumerate(step_sizes)\n        sol = solve(prob, Midpoint(), dt=Δh, adaptive=false, save_everystep=true)\n\n        timestamps = sol.t\n        sol_numeric_midpoint = sol.u\n        sol_analytic = analytical_solve.(timestamps)\n\n        separations = sol_numeric_midpoint .- sol_analytic\n        manhatten_errors = norm.(separations, Ref(1))\n        error_histories[i] = log10.(manhatten_errors)\n        time_histories[i] = timestamps\n    end\n    return time_histories, error_histories\nend\n\n\nend # module Benchmarks\n\n\n\n../media/problem09/numeric_and_analytical_trajectories.png\n\n\nNow, I will plot the steps sizes vs error (euclidean norm of state vector at tend):\n\n\n\n../media/problem09/steps_vs_error.png\n\n\nFor a better method, like RK4, on the same graph:\n\n\n\n../media/problem09/steps_vs_error_two_methods_compare.png\n\n\nNow, for time vs error compilation:\n\n\n\n../media/problem09/time_vs_running_error.png\n\n\nNow, I will change the relative tolerance and absolute tolerance. In file ./Ballistics/src/Benchmarks.jl:\nfunction tolerances_vs_error(prob, analytical_solve)\n    N = 15\n    error_matrix = Matrix{Float64}(undef, N, N)\n    num_granularity = N+7\n    abstols = 10.0 .^ range(7, -N, length=num_granularity)\n    reltols = 10.0 .^ range(7, -N, length=num_granularity)\n\n    num_samples = length(abstols)*length(reltols)\n\n    xs = Vector{Float64}(undef, num_samples)\n    ys = Vector{Float64}(undef, num_samples)\n    zs = Vector{Float64}(undef, num_samples)\n\n    for (i, abstol) in enumerate(abstols)\n        for (j, reltol) in enumerate(reltols)\n            sol_numeric = solve(prob, Midpoint(), adaptive=true, save_everystep=false, abstol=abstol, reltol=reltol)[end]\n            sol_analytic = analytical_solve(prob.tspan[2])\n\n            separation = sol_numeric - sol_analytic\n            error = norm(separation)\n            xs[i+num_granularity*(j-1)] = abstol\n            ys[i+num_granularity*(j-1)] = reltol\n            zs[i+num_granularity*(j-1)] = error\n        end\n    end\n    xs,ys,zs\nend\nJust by mistake I ran this for large (&gt;1.0) tolerances. Below is the plot:\n\n\n\n../media/problem09/large_tolerances.png\n\n\nSimilarly for tiny (&lt;&lt;1.0) tolerances the plot:\n\n\n\n../media/problem09/small_tolerances.png\n\n\nBoth scales on the same graph:\n\n\n\n../media/problem09/tolerances_vs_error_combined.png\n\n\nSimply put, it seems reducing both abstol and reltol generally reduces error from the analytic solution very quickly. What is the meaning of both is not yet entirely clear.\n\n\nUse larger and larger values of v0, plot all of their trajectory till ball hits ground. What happens to the eventual shape as v -&gt; ∞ ?\nThe code for this in file ./Ballistics/src/Ballistics.jl:\n# ...\n\nfunction solve_till_empty(prob)\n    conditionatbeggining(u, t, integrator) = t &gt; 0\n    removetstop!(integrator) = add_tstop!(integrator, ∞)\n    removetstopwhenbeginning = DiscreteCallback(conditionatbeggining,removetstop!)\n\n    condition(u, t, integrator) = u[2] &lt; 0\n    affect!(integrator) = terminate!(integrator)\n    stopwhenonground = DiscreteCallback(condition, affect!)\n\n    cb = CallbackSet(removetstopwhenbeginning, stopwhenonground)\n    sol = solve(prob, RK4(), callback = cb, tstops = [0.1,])\n\n    sol\nend\n\nfunction problem_setup(launchangle, speed0, c)\n    x0, y0 = 0.0, 0.0\n    r0 = [x0; y0]\n    vx0, vy0 = speed0 * [cos(launchangle); sin(launchangle)]\n    v0 = [vx0; vy0]\n    u0 = [r0; v0]\n\n    t0 = 0.0\n    tend = 1.0\n    tspan = (t0, tend)\n    p = Parameters.Param(m = 1, g = 1, c = c)\n    prob = ODEProblem(Physics.ballistic!, u0, tspan, p)\n    return prob\nend\n\nspeeds = range(0, 100)\nproblems = problem_setup.(Ref(pi/4), speeds, Ref(1))\nsols = solve_till_empty.(problems)\nVisualization.plot_all_trajectories(sols)\n\n# ...\nThe plot corresponding to this:\n\n\n\nIncreasing intial velocities\n\n\n\n\nPlot speed verses best launch angle, numerically or analyticaly or both\nI expect 45 degrees to still be consistantly good for launch even with drag.\nDoing this numerically, in file ./Ballistics/src/Benchmarks.jl:\n# ...\n\nfunction best_angle_for_speed(speed0, c)\n    launchangles = pi/4 .* ((range(-1.0, 1.0, 300)) .^ 3.0 .+ 1.0)\n\n    max_range = 0\n    argmax_theta = 0\n    for launchangle in launchangles\n        # problem setup\n        prob = problem_setup(launchangle, speed0, c)\n\n        sol = solve_till_empty(prob)\n        cur_range = sol.u[end][1]\n        if cur_range &gt; max_range\n            max_range = cur_range\n            argmax_theta = launchangle\n        end\n    end\n    argmax_theta\nend\n\nspeeds = 10.0 .^ range(0.0, 3.1, 100)\nbestangles = []\nfor speed0 in speeds\n    bestangle = best_angle_for_speed(speed0, 1)\n    push!(bestangles, bestangle)\nend\nVisualization.plot_best_angle_for_speeds(speeds, bestangles)\n\n# ...\nThe weird choice for launchangles is for concentrating numeric choices for launchangles near \\(\\pi \\over 4\\). This produces:\n\n\n\n../media/problem09/speed_vs_bestangle_c_1.png\n\n\n\n\n\n../media/problem09/speed_vs_bestangle_c_10.png\n\n\nIt seems that my intuition was way off. It seems the best angle quickly becomes closer to zero as the initial velocity increases.\nLet us plot the relation of drag with the best angle for a high velocity (say v = 1200), in file ./Ballistics/src/Ballistics.jl:\nspeed0 = 1200.0\nbestangles = []\ndrags = 2.0 .^ range(1.0, 5.0)\nfor c in drags\n    bestangle = best_angle_for_speed(speed0, c)\n    push!(bestangles, bestangle)\nend\nVisualization.plot_best_angle_vs_drag(drags, bestangles)\n\n\nTODO: There isn’t much change in the eventual best angle for large velocities as drag changes. It does not seem right, but the best angle in such case seems to be some constant close to zero. I will explore this more later. The plot generated by above code is:\n\n\n\n../media/problem09/best_angle_vs_drag.png\n\n\nThis concludes my attempt of problem09.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem09"
    ]
  },
  {
    "objectID": "content/DynamicsSimulations/problem11/index.html",
    "href": "content/DynamicsSimulations/problem11/index.html",
    "title": "problem11",
    "section": "",
    "text": "11. Central force. These two problems are both about central forces. In both cases the only force is central (directed on the particle towards the origin) and only depends on radius: \\(\\vec{\\mathbf{F}} = −F(r)\\mathbf{\\hat{e}_r}\\). The problems are independent, one does not follow from the other.\n\nFind a central force law \\(F(r)\\) so that, comparing circular orbits of varying radii, the speed v is independent of radius.\nBy numerical experiments, and trial and error, try to find a periodic motion that is neither circular nor a straight line, for some central force besides \\(F = −kr\\) or \\(F = \\frac{−GmM}{r2}\\) . a) not with a linear zero-rest length spring; b) not with inverse-square gravity; c) not circular motion; and d) not straight-line motion.\n\nIn your failed searches, before you find a periodic motion, do the motions always have regular patterns or are they sometimes chaotic looking (include some pretty pictures)?\nPuzzle: If you use a power law, what is the minimum number loops in one complete periodic orbit (a loop is, say, a relative maximum in the radius)? How does this depend on the exponent in the power law? You probably cannot make progress with this analytically, but you can figure it out with numerical experiments\n\n\n[Matlab hint: To do this properly you probably need to guess at a radial force law (most anything will work) and do numerical root finding (e.g., FSOLVE) to find initial conditions and the period of the orbit. Once you have your system you can define a function whose input is the initial conditions and the time of integration and whose output is the difference between the initial state and the final state. You can make this system ‘square’ by assuming that the particle is on the x axis in the initial state. You want to find that input which makes the output the zero vector. Pick a central force and search over initial conditions and durations. Do not use FSOLVE to search over force laws; do your orbit finding using a given force law]\n\n\n\n../media/problem11/problem11.png\n\n\n\n\n(a) Find a central force law \\(F(r)\\) so that, comparing circular orbits of varying radii, the speed v is independent of radius.\nConsider the relationship between centripetal force and velocity for uniform circular motion, since velocity is constant we can write:\n\\[F(r) = \\frac{mv^2}{r}\\]\n\\[F(r) = k\\frac{m}{r}\\]\nQuickly drawing the trajectory for tangential initial conditions, in file ./CentralForce/src/CentralForce.jl:\nu0 = [1.0;0.0;0.0;1.0]\ntspan = (0.0,10.0)\nm = 1.0\nk = 1.0\np = Param(m, k)\node = Physics.speedindependentofradius!\node_prob = DifferentialEquations.ODEProblem(ode, u0, tspan, p)\nsol = DifferentialEquations.solve(ode_prob)\nThis produces:\n\n\n\n../media/problem11/problem11_trajectory_central_force.png\n\n\nthe trajectory for non-tangential inital velocity:\n\n\nTODO: add graph for velocity vs radius\n\n\n(b) By numerical experiments, and trial and error, try to find a periodic motion that is neither circular nor a straight line, for some central force besides \\(F = −kr\\) or \\(F = \\frac{−GmM}{r2}\\) . a) not with a linear zero-rest length spring; b) not with inverse-square gravity; c) not circular motion; and d) not straight-line motion.\nFirst of all, I would like to note here that this was the most interesting and fun and investing problem so far in this problem set. I have spent almost 18 hours spread over 6 days on this problem.\nWe begin by formulating our problem:\nFor example, an interesting central force field is this:\nfunction dipolepowerlaw(r⃗, p)\n    p₁ = [1.0, 0.0]\n    p₂ = [0.0, +1.0]\n    p₃ = [-1.0, 0.0]\n    p₄ = [0.0, -1.0]\n    points = [p₁,p₂,p₃,p₄]\n    norms = norm.((r⃗ .- points))\n    k = -2\n    F = sum(inversepower.(norms, Ref{k}))\n    return F\nend\n#...\nfunction F(r⃗, p)\n    dipolepowerlaw(r⃗, p)\n    # speedindependentofradius(r⃗, p)\n    # inversepowerlaw(r⃗, p)\n    # hillinvalley(r⃗, p)\nend\n#...\nfunction centralforce!(du, u, p, t)\n    r⃗ = u[1:2]\n    v⃗ = u[3:4]\n    r̂ = normalize(r⃗)\n    F⃗ = F(r⃗, p) * (-r̂)\n    a⃗ = F⃗ / p.m\n    du[1:2] = v⃗\n    du[3:4] = a⃗\nend\nThe graph for this magnitude of this central force field looks like this:\n\n\n\nDipole power law\n\n\nFor any such function centralforce!(du, u::State, p::Parameters, tend:Time)::State, we want to find a \\(\\vec{u}_0\\) such that, for \\(\\vec{u}_t\\) = DifferentialEquations.solve(odeprob)[end]\n\\[\\vec{u}_t - \\vec{u}_0 = \\vec{0}\\]\nWhich is equivalent to finding a zero to the following function f, in file ./CentralForce/src/RootFinding.jl:\nf(z⃗₀, p) = begin\n    tol = 1e-12\n    u⃗₀ = z⃗₀[1:end-1]\n    tend = z⃗₀[end]\n    dynamics_prob = ProblemSetup.create_problem(ProblemSetup.ode!, u⃗₀, tend, p)\n    dynamics_sol = DifferentialEquations.solve(dynamics_prob; abstol=tol, reltol=tol, save_everystep=false)\n    u⃗ₜ = dynamics_sol.u[end]\n    Δu⃗ = u⃗ₜ - u⃗₀\n    phasecondition = u⃗₀[2] # crosses the x axis\n    # v⃗₀ = u⃗₀[3:4]\n    # limit = 0.1\n    # if LinearAlgebra.norm(v⃗₀) &lt; limit || tend &lt; 0.1\n    #     return zeros(5) .+ 1.0\n    # end\n    # Δu⃗\n    return [Δu⃗; phasecondition]\nend\nOne challenge I overcame after much thinking is regarding the phasecondition, the number of variables to solve for should equal the number of equations, earlier the input dimension was five: \\((x, y, vx, vy, tend)\\) while the output dimension was four (Δx, Δy, Δvx, Δvy).\nThe following is the question I asked in a julia help group online:\nIn the non-linear root finding, does the input dimension have to match the output dimensions?\nRight now I have input output dimension as 5, 4 respectively. input (5): (x, y, vx, vy, tend) output (4): (Δx, Δy, Δvx, Δvy )\nSomehow I feel this is not ideal. The system of nonlinear equations feels under defined. So, to correct this I added the constraint of solution roots should start on the y axis, i.e x = 0\nIn my system this is equivalent to:\nf(z⃗₀, p) = begin\n    tol = 1e-12\n\n    u⃗₀ = z⃗₀[1:end-1]\n    tend = z⃗₀[end]\n\n    dynamics_prob = ProblemSetup.create_problem(ProblemSetup.ode!, u⃗₀, tend, p)\n    dynamics_sol = DifferentialEquations.solve(dynamics_prob; abstol=tol, reltol=tol, save_everystep=false)\n    u⃗ₜ = dynamics_sol.u[end]\n    Δu⃗ = u⃗ₜ - u⃗₀\n\n    phasecondition = u⃗₀[2] # crosses the x axis\n\n    # v⃗₀ = u⃗₀[3:4]\n    # limit = 0.1\n    # if LinearAlgebra.norm(v⃗₀) &lt; limit || tend &lt; 0.1\n    #     return zeros(5) .+ 1.0\n    # end\n    # return Δu⃗\n    return [Δu⃗; phasecondition]\nend\nBut now the root finder is giving me this warning and gets stuck:\n Warning: Interrupted. Larger maxiters is needed. If you are using an integrator for non-stiff ODEs or an automatic switching algorithm (the default), you may want to consider using a method for stiff equations. See the solver pages for more details (e.g. https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#Stiff-Problems).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:589\n┌ Warning: Potential Rank Deficient Matrix Detected. Attempting to solve using Pivoted QR Factorization.\n└ @ NonlinearSolveBaseLinearSolveExt ~/.julia/packages/NonlinearSolveBase/yZeYz/ext/NonlinearSolveBaseLinearSolveExt.jl:33\n┌ Warning: At t=1.619487808996462e18, dt was forced below floating point epsilon 256.0, and step error estimate = 1.7742389634428446. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:623\n┌ Warning: Interrupted. Larger maxiters is needed. If you are using an integrator for non-stiff ODEs or an automatic switching algorithm (the default), you may want to consider using a method for stiff equations. See the solver pages for more details (e.g. https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/#Stiff-Problems).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:589\n┌ Warning: Potential Rank Deficient Matrix Detected. Attempting to solve using Pivoted QR Factorization.\n└ @ NonlinearSolveBaseLinearSolveExt ~/.julia/packages/NonlinearSolveBase/yZeYz/ext/NonlinearSolveBaseLinearSolveExt.jl:33\n┌ Warning: At t=1.619487808996462e18, dt was forced below floating point epsilon 256.0, and step error estimate = 1.7742389634428446. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).\n└ @ SciMLBase ~/.julia/packages/SciMLBase/cwnDi/src/integrator_interface.jl:623\nIs this because the phasecondition is linearly dependent to the state vector, I don't feel that is the case. What is going on?\nThe answer I got was by @romanveltz: “BifurcationKit does all that already”.\n\n\nTODO: Explore how BifurcationKit.jl achieves non-linear root finding.\nWe can formulate the solution to this either in an optimization way, or a root finding way.\nOne way to feed the initial conditions to the root solver is to keep doubling the norm of the initial condition vector, this is to avoid trivial roots: \\(tend = 0\\) or \\(v_0 = 0\\)\nIn julia, I use the NonlinearSolver. In file ./CentralForce/src/RootFinding.jl:\nfunction strategy_exponentiate()\n    randunitvec() = begin\n        θ = 2π*rand()\n        r = √(rand())\n        r*[cos(θ); sin(θ)]\n    end\n    \n    \n    tend_limit = 16000\n    v₀_limit = 1600\n    tend_init = 1.0\n    v₀_init = 1.0\n    factor = 2\n    periodic_sol = Vector{Float64}(undef, 5)\n    istrivial_tend_init = true\n    istrivial_v₀_init = true\n    varsinlimit() = begin\n        ((tend_init &lt; tend_limit) && (v₀_init &lt; v₀_limit))\n    end\n    varstrivial() = begin\n        (istrivial_tend_init || istrivial_v₀_init)\n    end\n    while varsinlimit() && varstrivial()\n        # local tend_init, istrivial_tend_init, v₀_init, istrivial_v₀_init, periodic_sol\n    \n        u⃗₀_init = [100*randunitvec(); v₀_init * randunitvec()]\n        z⃗₀_init = [u⃗₀_init; tend_init]\n    \n        root_prob = NonlinearSolve.NonlinearProblem(RootFinding.f, z⃗₀_init, ProblemSetup.p)\n        root_sol = NonlinearSolve.solve(root_prob)\n        println(\"Solver status: \", root_sol.retcode)\n        println(\"Residual norm: \", LinearAlgebra.norm(root_sol.resid))\n        u⃗₀_sol = root_sol[1:end - 1]\n        tend_sol = root_sol[end]\n        v⃗₀_sol = u⃗₀_sol[3:4]\n        v₀_sol = LinearAlgebra.norm(v⃗₀_sol)\n        println(\" ; root:tend_sol \", tend_sol, \" ; root:v₀_sol \", v₀_sol)\n        lowerlimit = 0.1\n        istrivial_tend_init = (tend_sol &lt; lowerlimit)\n        istrivial_v₀_init = (v₀_sol &lt; lowerlimit)\n        if varstrivial()\n            tend_init *= factor\n            v₀_init *= factor\n        else\n            println(\"Congratulations, found non-trivial periodic orbit\")\n            periodic_sol = root_sol\n        end\n        println(\"something trivial? : \", varstrivial())\n    end\n    \n    # periodic_sol = \n    # u⃗₀_periodic = periodic_sol[1:4]\n    # tend_periodic = periodic_sol[5]\n    # # plot the periodic solution\n    # plot_solution(ode!, u⃗₀_periodic, tend_periodic, p)\n    return periodic_sol\nend\nAnother strategy is to sample and pass every point in a mesh as a initial state to the solver, in the same file\nfunction strategy_meshcheck()\n    K = 100.0\n    N = 10\n    meshrange = range(-K, K, N)\n    meshtime = range(0.0, K, N)\n    count = 0\n    roots = []\n    println(\"Hello\")\n    for x in meshrange\n        for y in meshrange\n            for vx in meshrange\n                for vy in meshrange\n                    for t in meshtime\n                        global count\n                        r = LinearAlgebra.norm([x;y])\n                        v = LinearAlgebra.norm([vx;vy])\n                        if r &lt; 1.0 || v &lt; 1.0 || t &lt; 1.0\n                            println(\"skipping small cases\")\n                            continue\n                        end\n                        z⃗₀_init = [x; y; vx; vy; t]\n\n                        root_prob = NonlinearSolve.NonlinearProblem(RootFinding.f, z⃗₀_init, ProblemSetup.p)\n                        println(z⃗₀_init)\n                        root_sol = NonlinearSolve.solve(root_prob)\n\n                        count += 1\n                        percentage = 100*count / (N^length(z⃗₀_init))\n                        println(percentage, \"% completed\")\n\n                        if root_sol.retcode == NonlinearSolve.ReturnCode.Success\n                            push!(roots, root_sol)\n                        end\n                    end\n                end\n            end\n        end\n    end\n    println(\"Successfuly converged solutions: \", roots)\nend\nThe root finder was not converging for me for these.\nBut still with a bit of intuition I was able to find a non trivial Central Force Field with a non trivial periodic orbit, ./CentralForce/src/Physics.jl:\nFor the following force field:\n#...\nfunction hillinvalley(r⃗, p)\n    r = norm(r⃗)\n    σ = 5\n    a = 5\n    e = a*exp(-σ*r^2)\n    p = r^2\n    F = e+p #-a\nend\n#...\nThe graph of the magnitude of this force field:\n\n\n\nproblem11-hillinvalley-graph.png\n\n\nWith the follwoing intiial conditions, in file ./CentralForce/src/CentralForce.jl:\n#...\ntol = 1e-12\nfunction plot_solution(u⃗₀, tend)\n    ode_prob = ProblemSetup.create_problem(ProblemSetup.ode!, u⃗₀, tend, ProblemSetup.p)\n    sol = DifferentialEquations.solve(ode_prob, DifferentialEquations.Tsit5(); abstol=tol, reltol=tol, saveat=0.01)\n    trajectory = Visualization.plot_trajectory(sol)\n    GLMakie.save(\"./trajectory-solution.png\", trajectory)\n    GLMakie.display(trajectory)\nend\n#...\ntend = 50000.0\nr⃗ = [5, 5]\nv = 5.4225\nv⃗ = [-v, v]\nu⃗₀ = [r⃗; v⃗]\nplot_solution(u⃗₀, tend)\nWe get the very periodic orbit, ‘very’ meaning I dont have an analytical proof yet but have tested it for tend=5000:\n\n\n\nproblem11-hillinvalley-trajectory.png\n\n\nThe inconsistent use of code blocks and \\(math blocks\\) was an intentional fast.",
    "crumbs": [
      "Home",
      "Dynamics",
      "problem11"
    ]
  },
  {
    "objectID": "content/Resources/index.html",
    "href": "content/Resources/index.html",
    "title": "Resources",
    "section": "",
    "text": "I have not explored/read everything listed out here: if something is here, it just means that I am vaguely aware of said thing. Things I have some appreciation for are marked with a  and can be filtered by typing parsed in the search box on this page. Things I have passing or partial familiarity with are marked with a  and can be filtered by typing pseudo in the search box on this page.\nTo filter by tags, enter one of the following in the search box:\nprobability • logic • paper • folding • cutting • tiling • graphs • game • chess • geometry • card\n\n\n\n\n \n\n\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n28 Oct, 2022\nTo Not Checkmate\n chess   game    chess              game             \n\n\n14 Oct, 2022\nWindmill\n geometry    geometry             \n\n\n25 Mar, 2021\nTurn the LED on\n probability    probability             \n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/Resources/windmill/index.html",
    "href": "content/Resources/windmill/index.html",
    "title": "Windmill",
    "section": "",
    "text": "Source: IMO 2011, C3\n\n\n\n\n\n\nA hard puzzle with a beautiful solution.\n\n\n\n\nThe Problem\n\nLet \\(\\mathcal{S}\\) be a finite set of at least two points in the plane. Assume that no three points of \\(\\mathcal{S}\\) are collinear. By a windmill we mean a process as follows. Start with a line \\(\\ell\\) going through a point \\(P \\in \\mathcal{S}\\). Rotate \\(\\ell\\) clockwise around the pivot \\(P\\) until the line contains another point \\(Q\\) of \\(\\mathcal{S}\\). The point \\(Q\\) now takes over as the new pivot. This process continues indefinitely, with the pivot always being a point from \\(\\mathcal{S}\\).\nShow that for a suitable \\(P \\in \\mathcal{S}\\) and a suitable starting line \\(\\ell\\) containing \\(P\\), the resulting windmill will visit each point of \\(\\mathcal{S}\\) as a pivot infinitely often.\n\n Spoiler: a neat 3blue1brown video and lesson on the solution."
  }
]